// scripts/build-tokens.ts
/* eslint-disable no-console */
import { readdirSync, readFileSync, writeFileSync } from "node:fs";
import { join } from "node:path";
import { runInNewContext } from "node:vm";
import ts from "typescript";
export interface Token {
  readonly light: string;
  readonly dark?: string;
}
export type TokenMap = Record<`--${string}`, Token>;
// eslint-disable-next-line @typescript-eslint/no-var-requires
const { tokens } = require("../packages/themes/base/tokens.js") as {
  tokens: TokenMap;
};
/**
 * Create a plain-value stylesheet (no CSS variables).
 */
function generateStaticCss(map: TokenMap): string {
  let css = "/* Generated by build-tokens.ts */\n\n:root {\n";
  for (const [name, defs] of Object.entries(map)) {
    css += `  ${name}: ${defs.light};\n`;
  }
  css += "}\n";

  const darkEntries = Object.entries(map).filter(
    // narrow: keep only tokens that *do* define `dark`
    (entry): entry is [string, { light: string; dark: string }] =>
      entry[1].dark !== undefined
  );

  if (darkEntries.length) {
    css += "\n@media (prefers-color-scheme: dark) {\n  :root {\n";
    for (const [name, defs] of darkEntries) {
      css += `    ${name}: ${defs.dark};\n`;
    }
    css += "  }\n}\n";

    css += "html.theme-dark {\n";
    for (const [name, defs] of darkEntries) {
      css += `  ${name}: ${defs.dark};\n`;
    }
    css += "}\n";
  }
  return css;
}

/**
 * Create a CSS-variable stylesheet so end-users can override tokens.
 */
function generateDynamicCss(map: TokenMap): string {
  let css = "/* Generated by build-tokens.ts */\n\n:root {\n";
  for (const [name, defs] of Object.entries(map)) {
    const varName = `--token-${name.slice(2)}`;
    css += `  ${name}: var(${varName}, ${defs.light});\n`;
  }
  css += "}\n";

  const darkEntries = Object.entries(map).filter(
    (entry): entry is [string, { light: string; dark: string }] =>
      entry[1].dark !== undefined
  );

  if (darkEntries.length) {
    css += "\n@media (prefers-color-scheme: dark) {\n  :root {\n";
    for (const [name, defs] of darkEntries) {
      const varName = `--token-${name.slice(2)}-dark`;
      css += `    ${name}: var(${varName}, ${defs.dark});\n`;
    }
    css += "  }\n}\n";

    css += "html.theme-dark {\n";
    for (const [name, defs] of darkEntries) {
      const varName = `--token-${name.slice(2)}-dark`;
      css += `  ${name}: var(${varName}, ${defs.dark});\n`;
    }
    css += "}\n";
  }
  return css;
}

const outDir = join(__dirname, "..", "packages", "themes", "base");
writeFileSync(join(outDir, "tokens.static.css"), generateStaticCss(tokens));
writeFileSync(join(outDir, "tokens.dynamic.css"), generateDynamicCss(tokens));

console.log("→ tokens.static.css and tokens.dynamic.css generated");

/* -------------------------------------------------------------------------- */
/*  Additional theme tokens                                                   */
/* -------------------------------------------------------------------------- */

function generateThemeCss(map: Record<string, string>): string {
  let css = "/* Generated by build-tokens.ts */\n\n:root {\n";
  for (const [name, val] of Object.entries(map)) {
    css += `  ${name}: ${val};\n`;
  }
  css += "}\n";
  return css;
}

async function buildThemeCss(): Promise<void> {
  const themesDir = join(__dirname, "..", "packages", "themes");
  const themes = readdirSync(themesDir, { withFileTypes: true })
    .filter((d) => d.isDirectory() && d.name !== "base")
    .map((d) => d.name);

  for (const theme of themes) {
    const modPath = join(themesDir, theme, "tailwind-tokens.ts");
    const source = readFileSync(modPath, "utf8");
    const transpiled = ts.transpileModule(source, {
      compilerOptions: { module: ts.ModuleKind.CommonJS },
    }).outputText;
    const sandbox: {
      module: { exports: any };
      exports: any;
      require: NodeRequire;
    } = {
      module: { exports: {} },
      exports: {},
      require,
    };
    sandbox.exports = sandbox.module.exports;
    runInNewContext(transpiled, sandbox);
    const themeTokens = sandbox.module.exports.tokens as Record<string, string>;
    const css = generateThemeCss(themeTokens);
    writeFileSync(join(themesDir, theme, "tokens.css"), css);
  }
}

void buildThemeCss()
  .then(() => {
    console.log("→ theme tokens generated");
  })
  .catch((err) => {
    console.error(err);
    process.exit(1);
  });
