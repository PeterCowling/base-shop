#!/usr/bin/env bash
set -euo pipefail

# This wrapper is intended for agent shells only (see scripts/agents/with-git-guard.sh).
# It blocks a small set of destructive/history-rewriting commands that have caused
# accidental rollbacks and lost work.
#
# Source of truth: docs/git-safety.md § Command Policy Matrix
# When updating patterns, update the matrix first, then this script.

wrapper_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
real_git=""

IFS=":" read -r -a path_entries <<< "${PATH:-}"
for dir in "${path_entries[@]}"; do
  [[ -z "$dir" ]] && continue
  if [[ "$(cd "$dir" 2>/dev/null && pwd)" == "$wrapper_dir" ]]; then
    continue
  fi
  if [[ -x "${dir}/git" ]]; then
    real_git="${dir}/git"
    break
  fi
done

if [[ -z "$real_git" ]]; then
  echo "ERROR: unable to locate real git binary on PATH" >&2
  exit 127
fi

deny() {
  local why="$1"
  shift

  echo "------------------------------------------------------------------" >&2
  echo "GIT COMMAND BLOCKED (agent guard)" >&2
  echo "------------------------------------------------------------------" >&2
  echo "" >&2
  echo "Reason: ${why}" >&2
  echo "" >&2
  echo "Command:" >&2
  printf "  git"
  for arg in "$@"; do
    printf " %q" "$arg"
  done
  echo "" >&2
  echo "" >&2
  echo "Safer alternatives:" >&2
  echo "  - Make a checkpoint commit, then revert if needed" >&2
  echo "  - Use integrator mode (writer lock + guard): scripts/agents/integrator-shell.sh" >&2
  echo "  - Read: docs/git-safety.md" >&2
  echo "" >&2
  exit 1
}

subcommand="${1:-}"

# Block -c core.hooksPath (hook bypass)
for ((i=1; i<=$#; i++)); do
  arg="${!i}"
  if [[ "$arg" == "-c" ]]; then
    next_i=$((i+1))
    if [[ $next_i -le $# ]]; then
      next_arg="${!next_i}"
      if [[ "$next_arg" == core.hooksPath* ]]; then
        deny "Setting core.hooksPath bypasses git hooks." "$@"
      fi
    fi
  fi
done

# Block SKIP_* environment variable bypass attempts
for arg in "$@"; do
  if [[ "$arg" =~ ^SKIP_(WRITER_LOCK|SIMPLE_GIT_HOOKS) ]]; then
    deny "SKIP_* environment variables bypass safety hooks." "$@"
  fi
done

case "$subcommand" in
  worktree)
    deny "git worktree adds extra checkouts; Base-Shop workflow forbids worktrees." "$@"
    ;;
  reset)
    # Block reset with mode flags
    for arg in "$@"; do
      case "$arg" in
        --hard|--mixed|--merge|--keep)
          deny "git reset with mode flags rewrites state and can lose work." "$@"
          ;;
      esac
    done
    # Block bare reset to earlier commits (e.g. reset HEAD~N)
    # Allow: git reset HEAD file.txt (unstage)
    # Block: git reset HEAD~, git reset HEAD~1, etc.
    for arg in "$@"; do
      if [[ "$arg" =~ ^HEAD~[0-9]*$ ]]; then
        deny "Bare reset to earlier commit (HEAD~N) defaults to --mixed and can lose work." "$@"
      fi
    done
    ;;
  clean)
    # Block any -f variant, but allow dry-run (--dry-run / -n)
    has_dry_run="0"
    for arg in "$@"; do
      if [[ "$arg" == "--dry-run" || "$arg" == "-n" ]]; then
        has_dry_run="1"
      fi
    done

    if [[ "$has_dry_run" == "0" ]]; then
      for arg in "$@"; do
        # Match any flag combination containing 'f' (e.g. -f, -fd, -fdx, -ffdx, -fx)
        if [[ "$arg" =~ ^-[a-zA-Z]*f[a-zA-Z]*$ ]] || [[ "$arg" == "--force" ]]; then
          deny "git clean with -f permanently deletes untracked files. Use --dry-run first or move files to archive/." "$@"
        fi
      done
    fi
    ;;
  push)
    for arg in "$@"; do
      case "$arg" in
        --force|-f|--force-with-lease)
          deny "force-push rewrites remote history and can destroy teammates' work." "$@"
          ;;
        --mirror)
          deny "push --mirror can overwrite all remote refs and destroy work." "$@"
          ;;
        --no-verify|-n)
          deny "push --no-verify bypasses safety hooks." "$@"
          ;;
      esac
    done
    ;;
  rebase)
    deny "rebase rewrites history; use merge commits via PRs instead." "$@"
    ;;
  commit)
    for arg in "$@"; do
      case "$arg" in
        --amend)
          deny "amend rewrites history; prefer a new commit and merge via PR." "$@"
          ;;
        --no-verify)
          deny "commit --no-verify bypasses safety hooks." "$@"
          ;;
      esac
    done
    ;;
  checkout|restore)
    # Block repo-wide discards and force flags
    # Allow: single file restores
    # Block: '.', ':/...', directory paths, globs, --force, --worktree (on restore)

    # Check for force flags
    for arg in "$@"; do
      case "$arg" in
        -f|--force)
          deny "checkout/restore with --force discards local changes destructively." "$@"
          ;;
      esac
    done

    # For restore, block --worktree
    if [[ "$subcommand" == "restore" ]]; then
      for arg in "$@"; do
        if [[ "$arg" == "--worktree" ]]; then
          deny "restore --worktree can discard working tree changes." "$@"
        fi
      done
    fi

    # Block dangerous path patterns
    saw_separator="0"
    for arg in "$@"; do
      # Detect -- separator
      if [[ "$arg" == "--" ]]; then
        saw_separator="1"
        continue
      fi

      # Block repo-wide patterns
      case "$arg" in
        "."|":/"|":/."|":/*")
          deny "repo-wide checkout/restore discards changes." "$@"
          ;;
      esac

      # Block directory paths (ending in /)
      if [[ "$arg" =~ /$ ]]; then
        deny "directory checkout/restore (${arg}) can discard multiple files." "$@"
      fi

      # After --, block . or * or directory patterns
      if [[ "$saw_separator" == "1" ]]; then
        case "$arg" in
          "."|"*"|"*."|"*/*")
            deny "bulk checkout/restore pattern after -- (${arg}) can discard multiple files." "$@"
            ;;
        esac
        # Block paths ending in /
        if [[ "$arg" =~ /$ ]]; then
          deny "directory path after -- (${arg}) can discard multiple files." "$@"
        fi
      fi
    done
    ;;
  switch)
    # Block destructive switch operations
    for arg in "$@"; do
      case "$arg" in
        --discard-changes|-f|--force)
          deny "switch with --discard-changes/--force discards local changes." "$@"
          ;;
      esac
    done
    ;;
  stash)
    # Allow: list, show, push
    # Block: pop, apply, drop, clear, and bare stash (no subcommand)
    stash_subcmd="${2:-}"
    case "$stash_subcmd" in
      list|show|push)
        # Allowed
        ;;
      pop|apply|drop|clear)
        deny "stash ${stash_subcmd} can lose work or create merge conflicts." "$@"
        ;;
      "")
        # Bare 'git stash' defaults to 'git stash push' — allowed
        ;;
      *)
        # Unknown subcommand - block to be safe
        deny "stash subcommand '${stash_subcmd}' can hide or lose work in a multi-agent repo." "$@"
        ;;
    esac
    ;;
  config)
    # Block setting core.hooksPath
    for arg in "$@"; do
      if [[ "$arg" == "core.hooksPath" ]] || [[ "$arg" == core.hooksPath=* ]]; then
        deny "Setting core.hooksPath bypasses git hooks." "$@"
      fi
    done
    ;;
esac

exec "$real_git" "$@"
