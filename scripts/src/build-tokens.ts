// /scripts/src/build-tokens.ts
 

import { existsSync, readdirSync, readFileSync, writeFileSync } from "node:fs";
import { createRequire } from "node:module";
import path from "node:path";
import { fileURLToPath } from "node:url";
import { runInNewContext } from "node:vm";

import ts from "typescript";

import { tokens } from "../../packages/themes/base/src/tokens";

export interface Token {
  readonly light: string;
  readonly dark?: string;
}
export type TokenMap = Record<`--${string}`, Token>;

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const require = createRequire(import.meta.url);

/* -------------------------------------------------------------------------- */
/*  Base theme                                                                */
/* -------------------------------------------------------------------------- */

export function generateStaticCss(map: TokenMap): string {
  let css = "/* Generated by build-tokens.ts */\n\n:root {\n";
  const darkEntries: [string, { light: string; dark: string }][] = [];
  for (const [name, defs] of Object.entries(map)) {
    css += `  ${name}: ${defs.light};\n`;
    if (defs.dark !== undefined) {
      css += `  ${name}-dark: ${defs.dark};\n`;
      darkEntries.push([name, defs as { light: string; dark: string }]);
    }
  }
  css += "}\n";

  if (darkEntries.length) {
    css += "\n@media (prefers-color-scheme: dark) {\n  :root {\n";
    for (const [name] of darkEntries) {
      css += `    ${name}: var(${name}-dark);\n`;
    }
    css += "  }\n}\n";

    css += "\nhtml.theme-dark {\n";
    for (const [name] of darkEntries) {
      css += `  ${name}: var(${name}-dark);\n`;
    }
    css += "}\n";
  }
  return css;
}

export function generateDynamicCss(map: TokenMap): string {
  let css = "/* Generated by build-tokens.ts */\n\n:root {\n";
  const darkEntries: [string, { light: string; dark: string }][] = [];
  for (const [name, defs] of Object.entries(map)) {
    const varName = `--token-${name.slice(2)}`;
    css += `  ${name}: var(${varName}, ${defs.light});\n`;
    if (defs.dark !== undefined) {
      const darkVar = `--token-${name.slice(2)}-dark`;
      css += `  ${name}-dark: var(${darkVar}, ${defs.dark});\n`;
      darkEntries.push([name, defs as { light: string; dark: string }]);
    }
  }
  css += "}\n";

  if (darkEntries.length) {
    css += "\n@media (prefers-color-scheme: dark) {\n  :root {\n";
    for (const [name] of darkEntries) {
      css += `    ${name}: var(${name}-dark);\n`;
    }
    css += "  }\n}\n";

    css += "\nhtml.theme-dark {\n";
    for (const [name] of darkEntries) {
      css += `  ${name}: var(${name}-dark);\n`;
    }
    css += "}\n";
  }
  return css;
}

if (process.argv[1] === __filename) {
  const baseDir = path.resolve(
    __dirname,
    "..",
    "..",
    "packages",
    "themes",
    "base"
  );
  const dynamicCss = generateDynamicCss(tokens);
  writeFileSync(path.join(baseDir, "tokens.css"), dynamicCss);
  writeFileSync(
    path.join(baseDir, "tokens.static.css"),
    generateStaticCss(tokens)
  );
  writeFileSync(
    path.join(baseDir, "tokens.dynamic.css"),
    dynamicCss
  );

  console.log("→ tokens.css, tokens.static.css, and tokens.dynamic.css generated");

  /* ---------------------------------------------------------------------- */
  /*  Extra themes                                                          */
  /* ---------------------------------------------------------------------- */
}

export function generateThemeCss(map: Record<string, string>): string {
  let css = "/* Generated by build-tokens.ts */\n\n:root {\n";
  const darkEntries: [string, string][] = [];
  for (const [name, val] of Object.entries(map)) {
    css += `  ${name}: ${val};\n`;
    if (name.endsWith("-dark")) {
      const base = name.replace(/-dark$/, "");
      if (map[base] !== undefined) {
        darkEntries.push([base, name]);
      }
    }
  }
  css += "}\n";

  if (darkEntries.length) {
    css += "\n@media (prefers-color-scheme: dark) {\n  :root {\n";
    for (const [base, dark] of darkEntries) {
      css += `    ${base}: var(${dark});\n`;
    }
    css += "  }\n}\n";

    css += "\nhtml.theme-dark {\n";
    for (const [base, dark] of darkEntries) {
      css += `  ${base}: var(${dark});\n`;
    }
    css += "}\n";
  }

  return css;
}

function flattenTokenMap(map: TokenMap): Record<string, string> {
  const flattened: Record<string, string> = {};
  for (const [name, defs] of Object.entries(map)) {
    flattened[name] = defs.light;
    if (defs.dark !== undefined) {
      flattened[`${name}-dark`] = defs.dark;
    }
  }
  return flattened;
}

if (process.argv[1] === __filename) {
  async function buildThemeCss(): Promise<void> {
    const themesDir = path.resolve(__dirname, "..", "..", "packages", "themes");
    const themes = readdirSync(themesDir, { withFileTypes: true })
      .filter((d) => d.isDirectory() && d.name !== "base")
      .map((d) => d.name);

    const loadModuleExports = (modPath: string): Record<string, unknown> => {
      const source = readFileSync(modPath, "utf8");
      const transpiled = ts.transpileModule(source, {
        compilerOptions: { module: ts.ModuleKind.CommonJS },
      }).outputText;

      const sandbox: {
        module: { exports: Record<string, unknown> };
        exports: Record<string, unknown>;
        require: NodeRequire;
      } = {
        module: { exports: {} },
        exports: {},
        require,
      };
      sandbox.exports = sandbox.module.exports;
      runInNewContext(transpiled, sandbox);
      return sandbox.module.exports;
    };

    for (const theme of themes) {
      const tailwindPath = path.join(themesDir, theme, "src", "tailwind-tokens.ts");
      const tokensPath = path.join(themesDir, theme, "src", "tokens.ts");

      if (existsSync(tailwindPath)) {
        const themeTokens = loadModuleExports(tailwindPath).tokens as Record<string, string>;
        const css = generateThemeCss(themeTokens);
        writeFileSync(path.join(themesDir, theme, "tokens.css"), css);
        continue;
      }

      if (existsSync(tokensPath)) {
        const themeTokens = loadModuleExports(tokensPath).tokens as TokenMap;
        const css = generateThemeCss(flattenTokenMap(themeTokens));
        writeFileSync(path.join(themesDir, theme, "tokens.css"), css);
      }
    }
  }

  buildThemeCss()
    .then(() => console.log("→ theme tokens generated"))
    .catch((err) => {
      console.error(err);
      process.exit(1);
    });
}
