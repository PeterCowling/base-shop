// File: /src/hooks/mutations/useCancelBooking.ts

import { useCallback, useState } from "react";
import { get, ref } from "firebase/database";

import { useFirebaseDatabase } from "../../services/useFirebase";

import useActivitiesMutations from "./useActivitiesMutations";
import useArchiveBooking from "./useArchiveBooking";

/**
 * Return type for the useCancelBooking hook.
 */
interface UseCancelBookingReturn {
  cancelBooking: (bookingRef: string, reason?: string) => Promise<void>;
  loading: boolean;
  error: unknown;
}

/**
 * useCancelBooking:
 * Orchestrates the complete booking cancellation workflow.
 *
 * Workflow:
 *  1. Write status="cancelled" to /bookingMeta via useArchiveBooking
 *  2. Enumerate occupants from /bookings/{ref}
 *  3. Log activity code 27 (CANCELLED) for EACH occupant via useActivitiesMutations
 *  4. Keep guestsByBooking/{occupantId} intact (NOT deleted)
 *
 * Email drafts are auto-generated by useActivitiesMutations when code 27 is logged
 * (code 27 is in relevantCodes).
 *
 * TASK-11: Integration of Phase 1 email automation + Phase 2 soft-delete archival.
 */
export default function useCancelBooking(): UseCancelBookingReturn {
  const database = useFirebaseDatabase();
  const { archiveBooking } = useArchiveBooking();
  const { addActivity } = useActivitiesMutations();

  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<unknown>(null);

  /**
   * Cancels a booking by archiving status and logging activities for all occupants.
   */
  const cancelBooking = useCallback(
    async (bookingRef: string, reason?: string): Promise<void> => {
      if (!database) {
        const err = new Error("Database not initialized");
        setError(err);
        throw err;
      }

      setLoading(true);
      setError(null);

      try {
        // Step 1: Write status="cancelled" to /bookingMeta
        await archiveBooking(bookingRef, reason, "staff");

        // Step 2: Enumerate occupants from /bookings/{bookingRef}
        const bookingRef_ = ref(database, `bookings/${bookingRef}`);
        const snapshot = await get(bookingRef_);

        if (!snapshot.exists()) {
          throw new Error(`Booking ${bookingRef} not found`);
        }

        const occupantsData = snapshot.val() as Record<string, unknown>;
        const occupantIds = Object.keys(occupantsData);

        // Step 3: Log activity code 27 for each occupant
        // Code 27 triggers email via useActivitiesMutations (in relevantCodes)
        const activityPromises = occupantIds.map((occupantId) =>
          addActivity(occupantId, 27)
        );

        // Execute all activity logs (partial success acceptable)
        await Promise.all(activityPromises);

        // Step 4: guestsByBooking data remains intact (no deletion)
        // This is implicit - we only write, never delete
      } catch (err) {
        setError(err);
        throw err;
      } finally {
        setLoading(false);
      }
    },
    [database, archiveBooking, addActivity]
  );

  return {
    cancelBooking,
    loading,
    error,
  };
}
