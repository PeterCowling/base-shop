"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ulid@3.0.1";
exports.ids = ["vendor-chunks/ulid@3.0.1"];
exports.modules = {

/***/ "(rsc)/../../node_modules/.pnpm/ulid@3.0.1/node_modules/ulid/dist/node/index.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/.pnpm/ulid@3.0.1/node_modules/ulid/dist/node/index.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MAX_ULID: () => (/* binding */ MAX_ULID),\n/* harmony export */   MIN_ULID: () => (/* binding */ MIN_ULID),\n/* harmony export */   TIME_LEN: () => (/* binding */ TIME_LEN),\n/* harmony export */   TIME_MAX: () => (/* binding */ TIME_MAX),\n/* harmony export */   ULIDError: () => (/* binding */ ULIDError),\n/* harmony export */   ULIDErrorCode: () => (/* binding */ ULIDErrorCode),\n/* harmony export */   decodeTime: () => (/* binding */ decodeTime),\n/* harmony export */   encodeTime: () => (/* binding */ encodeTime),\n/* harmony export */   fixULIDBase32: () => (/* binding */ fixULIDBase32),\n/* harmony export */   incrementBase32: () => (/* binding */ incrementBase32),\n/* harmony export */   isValid: () => (/* binding */ isValid),\n/* harmony export */   monotonicFactory: () => (/* binding */ monotonicFactory),\n/* harmony export */   ulid: () => (/* binding */ ulid),\n/* harmony export */   ulidToUUID: () => (/* binding */ ulidToUUID),\n/* harmony export */   uuidToULID: () => (/* binding */ uuidToULID)\n/* harmony export */ });\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:crypto */ \"node:crypto\");\n\n\n// These values should NEVER change. The values are precisely for\n// generating ULIDs.\nconst B32_CHARACTERS = \"0123456789ABCDEFGHJKMNPQRSTVWXYZ\";\nconst ENCODING = \"0123456789ABCDEFGHJKMNPQRSTVWXYZ\"; // Crockford's Base32\nconst ENCODING_LEN = 32; // from ENCODING.length;\nconst MAX_ULID = \"7ZZZZZZZZZZZZZZZZZZZZZZZZZ\";\nconst MIN_ULID = \"00000000000000000000000000\";\nconst RANDOM_LEN = 16;\nconst TIME_LEN = 10;\nconst TIME_MAX = 281474976710655; // from Math.pow(2, 48) - 1;\nconst ULID_REGEX = /^[0-7][0-9a-hjkmnp-tv-zA-HJKMNP-TV-Z]{25}$/;\nconst UUID_REGEX = /^[0-9a-fA-F]{8}-(?:[0-9a-fA-F]{4}-){3}[0-9a-fA-F]{12}$/;\n\nvar ULIDErrorCode;\n(function (ULIDErrorCode) {\n    ULIDErrorCode[\"Base32IncorrectEncoding\"] = \"B32_ENC_INVALID\";\n    ULIDErrorCode[\"DecodeTimeInvalidCharacter\"] = \"DEC_TIME_CHAR\";\n    ULIDErrorCode[\"DecodeTimeValueMalformed\"] = \"DEC_TIME_MALFORMED\";\n    ULIDErrorCode[\"EncodeTimeNegative\"] = \"ENC_TIME_NEG\";\n    ULIDErrorCode[\"EncodeTimeSizeExceeded\"] = \"ENC_TIME_SIZE_EXCEED\";\n    ULIDErrorCode[\"EncodeTimeValueMalformed\"] = \"ENC_TIME_MALFORMED\";\n    ULIDErrorCode[\"PRNGDetectFailure\"] = \"PRNG_DETECT\";\n    ULIDErrorCode[\"ULIDInvalid\"] = \"ULID_INVALID\";\n    ULIDErrorCode[\"Unexpected\"] = \"UNEXPECTED\";\n    ULIDErrorCode[\"UUIDInvalid\"] = \"UUID_INVALID\";\n})(ULIDErrorCode || (ULIDErrorCode = {}));\nclass ULIDError extends Error {\n    constructor(errorCode, message) {\n        super(`${message} (${errorCode})`);\n        this.name = \"ULIDError\";\n        this.code = errorCode;\n    }\n}\n\nfunction randomChar(prng) {\n    // Currently PRNGs generate fractions from 0 to _less than_ 1, so no \"%\" is necessary.\n    // However, just in case a future PRNG can generate 1,\n    // we are applying \"% ENCODING LEN\" to wrap back to the first character\n    const randomPosition = Math.floor(prng() * ENCODING_LEN) % ENCODING_LEN;\n    return ENCODING.charAt(randomPosition);\n}\nfunction replaceCharAt(str, index, char) {\n    if (index > str.length - 1) {\n        return str;\n    }\n    return str.substr(0, index) + char + str.substr(index + 1);\n}\n\n// Code from https://github.com/devbanana/crockford-base32/blob/develop/src/index.ts\nfunction crockfordEncode(input) {\n    const output = [];\n    let bitsRead = 0;\n    let buffer = 0;\n    const reversedInput = new Uint8Array(input.slice().reverse());\n    for (const byte of reversedInput) {\n        buffer |= byte << bitsRead;\n        bitsRead += 8;\n        while (bitsRead >= 5) {\n            output.unshift(buffer & 0x1f);\n            buffer >>>= 5;\n            bitsRead -= 5;\n        }\n    }\n    if (bitsRead > 0) {\n        output.unshift(buffer & 0x1f);\n    }\n    return output.map(byte => B32_CHARACTERS.charAt(byte)).join(\"\");\n}\nfunction crockfordDecode(input) {\n    const sanitizedInput = input.toUpperCase().split(\"\").reverse().join(\"\");\n    const output = [];\n    let bitsRead = 0;\n    let buffer = 0;\n    for (const character of sanitizedInput) {\n        const byte = B32_CHARACTERS.indexOf(character);\n        if (byte === -1) {\n            throw new Error(`Invalid base 32 character found in string: ${character}`);\n        }\n        buffer |= byte << bitsRead;\n        bitsRead += 5;\n        while (bitsRead >= 8) {\n            output.unshift(buffer & 0xff);\n            buffer >>>= 8;\n            bitsRead -= 8;\n        }\n    }\n    if (bitsRead >= 5 || buffer > 0) {\n        output.unshift(buffer & 0xff);\n    }\n    return new Uint8Array(output);\n}\n/**\n * Fix a ULID's Base32 encoding -\n * i and l (case-insensitive) will be treated as 1 and o (case-insensitive) will be treated as 0.\n * hyphens are ignored during decoding.\n * @param id The ULID\n * @returns The cleaned up ULID\n */\nfunction fixULIDBase32(id) {\n    return id.replace(/i/gi, \"1\").replace(/l/gi, \"1\").replace(/o/gi, \"0\").replace(/-/g, \"\");\n}\nfunction incrementBase32(str) {\n    let done = undefined, index = str.length, char, charIndex, output = str;\n    const maxCharIndex = ENCODING_LEN - 1;\n    while (!done && index-- >= 0) {\n        char = output[index];\n        charIndex = ENCODING.indexOf(char);\n        if (charIndex === -1) {\n            throw new ULIDError(ULIDErrorCode.Base32IncorrectEncoding, \"Incorrectly encoded string\");\n        }\n        if (charIndex === maxCharIndex) {\n            output = replaceCharAt(output, index, ENCODING[0]);\n            continue;\n        }\n        done = replaceCharAt(output, index, ENCODING[charIndex + 1]);\n    }\n    if (typeof done === \"string\") {\n        return done;\n    }\n    throw new ULIDError(ULIDErrorCode.Base32IncorrectEncoding, \"Failed incrementing string\");\n}\n\n/**\n * Decode time from a ULID\n * @param id The ULID\n * @returns The decoded timestamp\n */\nfunction decodeTime(id) {\n    if (id.length !== TIME_LEN + RANDOM_LEN) {\n        throw new ULIDError(ULIDErrorCode.DecodeTimeValueMalformed, \"Malformed ULID\");\n    }\n    const time = id\n        .substr(0, TIME_LEN)\n        .toUpperCase()\n        .split(\"\")\n        .reverse()\n        .reduce((carry, char, index) => {\n        const encodingIndex = ENCODING.indexOf(char);\n        if (encodingIndex === -1) {\n            throw new ULIDError(ULIDErrorCode.DecodeTimeInvalidCharacter, `Time decode error: Invalid character: ${char}`);\n        }\n        return (carry += encodingIndex * Math.pow(ENCODING_LEN, index));\n    }, 0);\n    if (time > TIME_MAX) {\n        throw new ULIDError(ULIDErrorCode.DecodeTimeValueMalformed, `Malformed ULID: timestamp too large: ${time}`);\n    }\n    return time;\n}\n/**\n * Detect the best PRNG (pseudo-random number generator)\n * @param root The root to check from (global/window)\n * @returns The PRNG function\n */\nfunction detectPRNG(root) {\n    const rootLookup = detectRoot();\n    const globalCrypto = (rootLookup && (rootLookup.crypto || rootLookup.msCrypto)) ||\n        (typeof node_crypto__WEBPACK_IMPORTED_MODULE_0__ !== \"undefined\" ? node_crypto__WEBPACK_IMPORTED_MODULE_0__ : null);\n    if (typeof globalCrypto?.getRandomValues === \"function\") {\n        return () => {\n            const buffer = new Uint8Array(1);\n            globalCrypto.getRandomValues(buffer);\n            return buffer[0] / 0xff;\n        };\n    }\n    else if (typeof globalCrypto?.randomBytes === \"function\") {\n        return () => globalCrypto.randomBytes(1).readUInt8() / 0xff;\n    }\n    else if (node_crypto__WEBPACK_IMPORTED_MODULE_0__?.randomBytes) {\n        return () => node_crypto__WEBPACK_IMPORTED_MODULE_0__.randomBytes(1).readUInt8() / 0xff;\n    }\n    throw new ULIDError(ULIDErrorCode.PRNGDetectFailure, \"Failed to find a reliable PRNG\");\n}\nfunction detectRoot() {\n    if (inWebWorker())\n        return self;\n    if (typeof window !== \"undefined\") {\n        return window;\n    }\n    if (typeof global !== \"undefined\") {\n        return global;\n    }\n    if (typeof globalThis !== \"undefined\") {\n        return globalThis;\n    }\n    return null;\n}\nfunction encodeRandom(len, prng) {\n    let str = \"\";\n    for (; len > 0; len--) {\n        str = randomChar(prng) + str;\n    }\n    return str;\n}\n/**\n * Encode the time portion of a ULID\n * @param now The current timestamp\n * @param len Length to generate\n * @returns The encoded time\n */\nfunction encodeTime(now, len = TIME_LEN) {\n    if (isNaN(now)) {\n        throw new ULIDError(ULIDErrorCode.EncodeTimeValueMalformed, `Time must be a number: ${now}`);\n    }\n    else if (now > TIME_MAX) {\n        throw new ULIDError(ULIDErrorCode.EncodeTimeSizeExceeded, `Cannot encode a time larger than ${TIME_MAX}: ${now}`);\n    }\n    else if (now < 0) {\n        throw new ULIDError(ULIDErrorCode.EncodeTimeNegative, `Time must be positive: ${now}`);\n    }\n    else if (Number.isInteger(now) === false) {\n        throw new ULIDError(ULIDErrorCode.EncodeTimeValueMalformed, `Time must be an integer: ${now}`);\n    }\n    let mod, str = \"\";\n    for (let currentLen = len; currentLen > 0; currentLen--) {\n        mod = now % ENCODING_LEN;\n        str = ENCODING.charAt(mod) + str;\n        now = (now - mod) / ENCODING_LEN;\n    }\n    return str;\n}\nfunction inWebWorker() {\n    // @ts-ignore\n    return typeof WorkerGlobalScope !== \"undefined\" && self instanceof WorkerGlobalScope;\n}\n/**\n * Check if a ULID is valid\n * @param id The ULID to test\n * @returns True if valid, false otherwise\n * @example\n *   isValid(\"01HNZX8JGFACFA36RBXDHEQN6E\"); // true\n *   isValid(\"\"); // false\n */\nfunction isValid(id) {\n    return (typeof id === \"string\" &&\n        id.length === TIME_LEN + RANDOM_LEN &&\n        id\n            .toUpperCase()\n            .split(\"\")\n            .every(char => ENCODING.indexOf(char) !== -1));\n}\n/**\n * Create a ULID factory to generate monotonically-increasing\n *  ULIDs\n * @param prng The PRNG to use\n * @returns A ulid factory\n * @example\n *  const ulid = monotonicFactory();\n *  ulid(); // \"01HNZXD07M5CEN5XA66EMZSRZW\"\n */\nfunction monotonicFactory(prng) {\n    const currentPRNG = prng || detectPRNG();\n    let lastTime = 0, lastRandom;\n    return function _ulid(seedTime) {\n        const seed = !seedTime || isNaN(seedTime) ? Date.now() : seedTime;\n        if (seed <= lastTime) {\n            const incrementedRandom = (lastRandom = incrementBase32(lastRandom));\n            return encodeTime(lastTime, TIME_LEN) + incrementedRandom;\n        }\n        lastTime = seed;\n        const newRandom = (lastRandom = encodeRandom(RANDOM_LEN, currentPRNG));\n        return encodeTime(seed, TIME_LEN) + newRandom;\n    };\n}\n/**\n * Generate a ULID\n * @param seedTime Optional time seed\n * @param prng Optional PRNG function\n * @returns A ULID string\n * @example\n *  ulid(); // \"01HNZXD07M5CEN5XA66EMZSRZW\"\n */\nfunction ulid(seedTime, prng) {\n    const currentPRNG = prng || detectPRNG();\n    const seed = !seedTime || isNaN(seedTime) ? Date.now() : seedTime;\n    return encodeTime(seed, TIME_LEN) + encodeRandom(RANDOM_LEN, currentPRNG);\n}\n\n/**\n * Convert a ULID to a UUID\n * @param ulid The ULID to convert\n * @returns A UUID string\n */\nfunction ulidToUUID(ulid) {\n    const isValid = ULID_REGEX.test(ulid);\n    if (!isValid) {\n        throw new ULIDError(ULIDErrorCode.ULIDInvalid, `Invalid ULID: ${ulid}`);\n    }\n    const uint8Array = crockfordDecode(ulid);\n    let uuid = Array.from(uint8Array)\n        .map(byte => byte.toString(16).padStart(2, \"0\"))\n        .join(\"\");\n    uuid =\n        uuid.substring(0, 8) +\n            \"-\" +\n            uuid.substring(8, 12) +\n            \"-\" +\n            uuid.substring(12, 16) +\n            \"-\" +\n            uuid.substring(16, 20) +\n            \"-\" +\n            uuid.substring(20);\n    return uuid.toUpperCase();\n}\n/**\n * Convert a UUID to a ULID\n * @param uuid The UUID to convert\n * @returns A ULID string\n */\nfunction uuidToULID(uuid) {\n    const isValid = UUID_REGEX.test(uuid);\n    if (!isValid) {\n        throw new ULIDError(ULIDErrorCode.UUIDInvalid, `Invalid UUID: ${uuid}`);\n    }\n    const bytes = uuid.replace(/-/g, \"\").match(/.{1,2}/g);\n    if (!bytes) {\n        throw new ULIDError(ULIDErrorCode.Unexpected, `Failed parsing UUID bytes: ${uuid}`);\n    }\n    const uint8Array = new Uint8Array(bytes.map(byte => parseInt(byte, 16)));\n    return crockfordEncode(uint8Array);\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3VsaWRAMy4wLjEvbm9kZV9tb2R1bGVzL3VsaWQvZGlzdC9ub2RlL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBaUM7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRCx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEMsMERBQTBELEdBQUc7QUFDN0QsaUNBQWlDLEVBQUUsZ0JBQWdCLEVBQUUsR0FBRyxFQUFFLFlBQVksR0FBRzs7QUFFekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzQ0FBc0M7QUFDdkM7QUFDQTtBQUNBLGlCQUFpQixTQUFTLEdBQUcsVUFBVTtBQUN2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxVQUFVO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1IQUFtSCxLQUFLO0FBQ3hIO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSw0R0FBNEcsS0FBSztBQUNqSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHdDQUFNLG1CQUFtQix3Q0FBTTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsd0NBQU07QUFDbkIscUJBQXFCLG9EQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RkFBOEYsSUFBSTtBQUNsRztBQUNBO0FBQ0Esc0dBQXNHLFNBQVMsSUFBSSxJQUFJO0FBQ3ZIO0FBQ0E7QUFDQSx3RkFBd0YsSUFBSTtBQUM1RjtBQUNBO0FBQ0EsZ0dBQWdHLElBQUk7QUFDcEc7QUFDQTtBQUNBLCtCQUErQixnQkFBZ0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsS0FBSztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxLQUFLO0FBQzdFO0FBQ0Esa0RBQWtELElBQUk7QUFDdEQ7QUFDQSxvRkFBb0YsS0FBSztBQUN6RjtBQUNBO0FBQ0E7QUFDQTs7QUFFNkwiLCJzb3VyY2VzIjpbIi9Vc2Vycy9wZXRlcmNvd2xpbmcvcmVjZXB0aW9uL2Jhc2Utc2hvcC9ub2RlX21vZHVsZXMvLnBucG0vdWxpZEAzLjAuMS9ub2RlX21vZHVsZXMvdWxpZC9kaXN0L25vZGUvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGNyeXB0byBmcm9tICdub2RlOmNyeXB0byc7XG5cbi8vIFRoZXNlIHZhbHVlcyBzaG91bGQgTkVWRVIgY2hhbmdlLiBUaGUgdmFsdWVzIGFyZSBwcmVjaXNlbHkgZm9yXG4vLyBnZW5lcmF0aW5nIFVMSURzLlxuY29uc3QgQjMyX0NIQVJBQ1RFUlMgPSBcIjAxMjM0NTY3ODlBQkNERUZHSEpLTU5QUVJTVFZXWFlaXCI7XG5jb25zdCBFTkNPRElORyA9IFwiMDEyMzQ1Njc4OUFCQ0RFRkdISktNTlBRUlNUVldYWVpcIjsgLy8gQ3JvY2tmb3JkJ3MgQmFzZTMyXG5jb25zdCBFTkNPRElOR19MRU4gPSAzMjsgLy8gZnJvbSBFTkNPRElORy5sZW5ndGg7XG5jb25zdCBNQVhfVUxJRCA9IFwiN1paWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpcIjtcbmNvbnN0IE1JTl9VTElEID0gXCIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiO1xuY29uc3QgUkFORE9NX0xFTiA9IDE2O1xuY29uc3QgVElNRV9MRU4gPSAxMDtcbmNvbnN0IFRJTUVfTUFYID0gMjgxNDc0OTc2NzEwNjU1OyAvLyBmcm9tIE1hdGgucG93KDIsIDQ4KSAtIDE7XG5jb25zdCBVTElEX1JFR0VYID0gL15bMC03XVswLTlhLWhqa21ucC10di16QS1ISktNTlAtVFYtWl17MjV9JC87XG5jb25zdCBVVUlEX1JFR0VYID0gL15bMC05YS1mQS1GXXs4fS0oPzpbMC05YS1mQS1GXXs0fS0pezN9WzAtOWEtZkEtRl17MTJ9JC87XG5cbnZhciBVTElERXJyb3JDb2RlO1xuKGZ1bmN0aW9uIChVTElERXJyb3JDb2RlKSB7XG4gICAgVUxJREVycm9yQ29kZVtcIkJhc2UzMkluY29ycmVjdEVuY29kaW5nXCJdID0gXCJCMzJfRU5DX0lOVkFMSURcIjtcbiAgICBVTElERXJyb3JDb2RlW1wiRGVjb2RlVGltZUludmFsaWRDaGFyYWN0ZXJcIl0gPSBcIkRFQ19USU1FX0NIQVJcIjtcbiAgICBVTElERXJyb3JDb2RlW1wiRGVjb2RlVGltZVZhbHVlTWFsZm9ybWVkXCJdID0gXCJERUNfVElNRV9NQUxGT1JNRURcIjtcbiAgICBVTElERXJyb3JDb2RlW1wiRW5jb2RlVGltZU5lZ2F0aXZlXCJdID0gXCJFTkNfVElNRV9ORUdcIjtcbiAgICBVTElERXJyb3JDb2RlW1wiRW5jb2RlVGltZVNpemVFeGNlZWRlZFwiXSA9IFwiRU5DX1RJTUVfU0laRV9FWENFRURcIjtcbiAgICBVTElERXJyb3JDb2RlW1wiRW5jb2RlVGltZVZhbHVlTWFsZm9ybWVkXCJdID0gXCJFTkNfVElNRV9NQUxGT1JNRURcIjtcbiAgICBVTElERXJyb3JDb2RlW1wiUFJOR0RldGVjdEZhaWx1cmVcIl0gPSBcIlBSTkdfREVURUNUXCI7XG4gICAgVUxJREVycm9yQ29kZVtcIlVMSURJbnZhbGlkXCJdID0gXCJVTElEX0lOVkFMSURcIjtcbiAgICBVTElERXJyb3JDb2RlW1wiVW5leHBlY3RlZFwiXSA9IFwiVU5FWFBFQ1RFRFwiO1xuICAgIFVMSURFcnJvckNvZGVbXCJVVUlESW52YWxpZFwiXSA9IFwiVVVJRF9JTlZBTElEXCI7XG59KShVTElERXJyb3JDb2RlIHx8IChVTElERXJyb3JDb2RlID0ge30pKTtcbmNsYXNzIFVMSURFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihlcnJvckNvZGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIoYCR7bWVzc2FnZX0gKCR7ZXJyb3JDb2RlfSlgKTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJVTElERXJyb3JcIjtcbiAgICAgICAgdGhpcy5jb2RlID0gZXJyb3JDb2RlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcmFuZG9tQ2hhcihwcm5nKSB7XG4gICAgLy8gQ3VycmVudGx5IFBSTkdzIGdlbmVyYXRlIGZyYWN0aW9ucyBmcm9tIDAgdG8gX2xlc3MgdGhhbl8gMSwgc28gbm8gXCIlXCIgaXMgbmVjZXNzYXJ5LlxuICAgIC8vIEhvd2V2ZXIsIGp1c3QgaW4gY2FzZSBhIGZ1dHVyZSBQUk5HIGNhbiBnZW5lcmF0ZSAxLFxuICAgIC8vIHdlIGFyZSBhcHBseWluZyBcIiUgRU5DT0RJTkcgTEVOXCIgdG8gd3JhcCBiYWNrIHRvIHRoZSBmaXJzdCBjaGFyYWN0ZXJcbiAgICBjb25zdCByYW5kb21Qb3NpdGlvbiA9IE1hdGguZmxvb3IocHJuZygpICogRU5DT0RJTkdfTEVOKSAlIEVOQ09ESU5HX0xFTjtcbiAgICByZXR1cm4gRU5DT0RJTkcuY2hhckF0KHJhbmRvbVBvc2l0aW9uKTtcbn1cbmZ1bmN0aW9uIHJlcGxhY2VDaGFyQXQoc3RyLCBpbmRleCwgY2hhcikge1xuICAgIGlmIChpbmRleCA+IHN0ci5sZW5ndGggLSAxKSB7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIHJldHVybiBzdHIuc3Vic3RyKDAsIGluZGV4KSArIGNoYXIgKyBzdHIuc3Vic3RyKGluZGV4ICsgMSk7XG59XG5cbi8vIENvZGUgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZGV2YmFuYW5hL2Nyb2NrZm9yZC1iYXNlMzIvYmxvYi9kZXZlbG9wL3NyYy9pbmRleC50c1xuZnVuY3Rpb24gY3JvY2tmb3JkRW5jb2RlKGlucHV0KSB7XG4gICAgY29uc3Qgb3V0cHV0ID0gW107XG4gICAgbGV0IGJpdHNSZWFkID0gMDtcbiAgICBsZXQgYnVmZmVyID0gMDtcbiAgICBjb25zdCByZXZlcnNlZElucHV0ID0gbmV3IFVpbnQ4QXJyYXkoaW5wdXQuc2xpY2UoKS5yZXZlcnNlKCkpO1xuICAgIGZvciAoY29uc3QgYnl0ZSBvZiByZXZlcnNlZElucHV0KSB7XG4gICAgICAgIGJ1ZmZlciB8PSBieXRlIDw8IGJpdHNSZWFkO1xuICAgICAgICBiaXRzUmVhZCArPSA4O1xuICAgICAgICB3aGlsZSAoYml0c1JlYWQgPj0gNSkge1xuICAgICAgICAgICAgb3V0cHV0LnVuc2hpZnQoYnVmZmVyICYgMHgxZik7XG4gICAgICAgICAgICBidWZmZXIgPj4+PSA1O1xuICAgICAgICAgICAgYml0c1JlYWQgLT0gNTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoYml0c1JlYWQgPiAwKSB7XG4gICAgICAgIG91dHB1dC51bnNoaWZ0KGJ1ZmZlciAmIDB4MWYpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0Lm1hcChieXRlID0+IEIzMl9DSEFSQUNURVJTLmNoYXJBdChieXRlKSkuam9pbihcIlwiKTtcbn1cbmZ1bmN0aW9uIGNyb2NrZm9yZERlY29kZShpbnB1dCkge1xuICAgIGNvbnN0IHNhbml0aXplZElucHV0ID0gaW5wdXQudG9VcHBlckNhc2UoKS5zcGxpdChcIlwiKS5yZXZlcnNlKCkuam9pbihcIlwiKTtcbiAgICBjb25zdCBvdXRwdXQgPSBbXTtcbiAgICBsZXQgYml0c1JlYWQgPSAwO1xuICAgIGxldCBidWZmZXIgPSAwO1xuICAgIGZvciAoY29uc3QgY2hhcmFjdGVyIG9mIHNhbml0aXplZElucHV0KSB7XG4gICAgICAgIGNvbnN0IGJ5dGUgPSBCMzJfQ0hBUkFDVEVSUy5pbmRleE9mKGNoYXJhY3Rlcik7XG4gICAgICAgIGlmIChieXRlID09PSAtMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGJhc2UgMzIgY2hhcmFjdGVyIGZvdW5kIGluIHN0cmluZzogJHtjaGFyYWN0ZXJ9YCk7XG4gICAgICAgIH1cbiAgICAgICAgYnVmZmVyIHw9IGJ5dGUgPDwgYml0c1JlYWQ7XG4gICAgICAgIGJpdHNSZWFkICs9IDU7XG4gICAgICAgIHdoaWxlIChiaXRzUmVhZCA+PSA4KSB7XG4gICAgICAgICAgICBvdXRwdXQudW5zaGlmdChidWZmZXIgJiAweGZmKTtcbiAgICAgICAgICAgIGJ1ZmZlciA+Pj49IDg7XG4gICAgICAgICAgICBiaXRzUmVhZCAtPSA4O1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChiaXRzUmVhZCA+PSA1IHx8IGJ1ZmZlciA+IDApIHtcbiAgICAgICAgb3V0cHV0LnVuc2hpZnQoYnVmZmVyICYgMHhmZik7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVWludDhBcnJheShvdXRwdXQpO1xufVxuLyoqXG4gKiBGaXggYSBVTElEJ3MgQmFzZTMyIGVuY29kaW5nIC1cbiAqIGkgYW5kIGwgKGNhc2UtaW5zZW5zaXRpdmUpIHdpbGwgYmUgdHJlYXRlZCBhcyAxIGFuZCBvIChjYXNlLWluc2Vuc2l0aXZlKSB3aWxsIGJlIHRyZWF0ZWQgYXMgMC5cbiAqIGh5cGhlbnMgYXJlIGlnbm9yZWQgZHVyaW5nIGRlY29kaW5nLlxuICogQHBhcmFtIGlkIFRoZSBVTElEXG4gKiBAcmV0dXJucyBUaGUgY2xlYW5lZCB1cCBVTElEXG4gKi9cbmZ1bmN0aW9uIGZpeFVMSURCYXNlMzIoaWQpIHtcbiAgICByZXR1cm4gaWQucmVwbGFjZSgvaS9naSwgXCIxXCIpLnJlcGxhY2UoL2wvZ2ksIFwiMVwiKS5yZXBsYWNlKC9vL2dpLCBcIjBcIikucmVwbGFjZSgvLS9nLCBcIlwiKTtcbn1cbmZ1bmN0aW9uIGluY3JlbWVudEJhc2UzMihzdHIpIHtcbiAgICBsZXQgZG9uZSA9IHVuZGVmaW5lZCwgaW5kZXggPSBzdHIubGVuZ3RoLCBjaGFyLCBjaGFySW5kZXgsIG91dHB1dCA9IHN0cjtcbiAgICBjb25zdCBtYXhDaGFySW5kZXggPSBFTkNPRElOR19MRU4gLSAxO1xuICAgIHdoaWxlICghZG9uZSAmJiBpbmRleC0tID49IDApIHtcbiAgICAgICAgY2hhciA9IG91dHB1dFtpbmRleF07XG4gICAgICAgIGNoYXJJbmRleCA9IEVOQ09ESU5HLmluZGV4T2YoY2hhcik7XG4gICAgICAgIGlmIChjaGFySW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVUxJREVycm9yKFVMSURFcnJvckNvZGUuQmFzZTMySW5jb3JyZWN0RW5jb2RpbmcsIFwiSW5jb3JyZWN0bHkgZW5jb2RlZCBzdHJpbmdcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYXJJbmRleCA9PT0gbWF4Q2hhckluZGV4KSB7XG4gICAgICAgICAgICBvdXRwdXQgPSByZXBsYWNlQ2hhckF0KG91dHB1dCwgaW5kZXgsIEVOQ09ESU5HWzBdKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGRvbmUgPSByZXBsYWNlQ2hhckF0KG91dHB1dCwgaW5kZXgsIEVOQ09ESU5HW2NoYXJJbmRleCArIDFdKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBkb25lID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBkb25lO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgVUxJREVycm9yKFVMSURFcnJvckNvZGUuQmFzZTMySW5jb3JyZWN0RW5jb2RpbmcsIFwiRmFpbGVkIGluY3JlbWVudGluZyBzdHJpbmdcIik7XG59XG5cbi8qKlxuICogRGVjb2RlIHRpbWUgZnJvbSBhIFVMSURcbiAqIEBwYXJhbSBpZCBUaGUgVUxJRFxuICogQHJldHVybnMgVGhlIGRlY29kZWQgdGltZXN0YW1wXG4gKi9cbmZ1bmN0aW9uIGRlY29kZVRpbWUoaWQpIHtcbiAgICBpZiAoaWQubGVuZ3RoICE9PSBUSU1FX0xFTiArIFJBTkRPTV9MRU4pIHtcbiAgICAgICAgdGhyb3cgbmV3IFVMSURFcnJvcihVTElERXJyb3JDb2RlLkRlY29kZVRpbWVWYWx1ZU1hbGZvcm1lZCwgXCJNYWxmb3JtZWQgVUxJRFwiKTtcbiAgICB9XG4gICAgY29uc3QgdGltZSA9IGlkXG4gICAgICAgIC5zdWJzdHIoMCwgVElNRV9MRU4pXG4gICAgICAgIC50b1VwcGVyQ2FzZSgpXG4gICAgICAgIC5zcGxpdChcIlwiKVxuICAgICAgICAucmV2ZXJzZSgpXG4gICAgICAgIC5yZWR1Y2UoKGNhcnJ5LCBjaGFyLCBpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCBlbmNvZGluZ0luZGV4ID0gRU5DT0RJTkcuaW5kZXhPZihjaGFyKTtcbiAgICAgICAgaWYgKGVuY29kaW5nSW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVUxJREVycm9yKFVMSURFcnJvckNvZGUuRGVjb2RlVGltZUludmFsaWRDaGFyYWN0ZXIsIGBUaW1lIGRlY29kZSBlcnJvcjogSW52YWxpZCBjaGFyYWN0ZXI6ICR7Y2hhcn1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGNhcnJ5ICs9IGVuY29kaW5nSW5kZXggKiBNYXRoLnBvdyhFTkNPRElOR19MRU4sIGluZGV4KSk7XG4gICAgfSwgMCk7XG4gICAgaWYgKHRpbWUgPiBUSU1FX01BWCkge1xuICAgICAgICB0aHJvdyBuZXcgVUxJREVycm9yKFVMSURFcnJvckNvZGUuRGVjb2RlVGltZVZhbHVlTWFsZm9ybWVkLCBgTWFsZm9ybWVkIFVMSUQ6IHRpbWVzdGFtcCB0b28gbGFyZ2U6ICR7dGltZX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHRpbWU7XG59XG4vKipcbiAqIERldGVjdCB0aGUgYmVzdCBQUk5HIChwc2V1ZG8tcmFuZG9tIG51bWJlciBnZW5lcmF0b3IpXG4gKiBAcGFyYW0gcm9vdCBUaGUgcm9vdCB0byBjaGVjayBmcm9tIChnbG9iYWwvd2luZG93KVxuICogQHJldHVybnMgVGhlIFBSTkcgZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gZGV0ZWN0UFJORyhyb290KSB7XG4gICAgY29uc3Qgcm9vdExvb2t1cCA9IGRldGVjdFJvb3QoKTtcbiAgICBjb25zdCBnbG9iYWxDcnlwdG8gPSAocm9vdExvb2t1cCAmJiAocm9vdExvb2t1cC5jcnlwdG8gfHwgcm9vdExvb2t1cC5tc0NyeXB0bykpIHx8XG4gICAgICAgICh0eXBlb2YgY3J5cHRvICE9PSBcInVuZGVmaW5lZFwiID8gY3J5cHRvIDogbnVsbCk7XG4gICAgaWYgKHR5cGVvZiBnbG9iYWxDcnlwdG8/LmdldFJhbmRvbVZhbHVlcyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBidWZmZXIgPSBuZXcgVWludDhBcnJheSgxKTtcbiAgICAgICAgICAgIGdsb2JhbENyeXB0by5nZXRSYW5kb21WYWx1ZXMoYnVmZmVyKTtcbiAgICAgICAgICAgIHJldHVybiBidWZmZXJbMF0gLyAweGZmO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsQ3J5cHRvPy5yYW5kb21CeXRlcyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiAoKSA9PiBnbG9iYWxDcnlwdG8ucmFuZG9tQnl0ZXMoMSkucmVhZFVJbnQ4KCkgLyAweGZmO1xuICAgIH1cbiAgICBlbHNlIGlmIChjcnlwdG8/LnJhbmRvbUJ5dGVzKSB7XG4gICAgICAgIHJldHVybiAoKSA9PiBjcnlwdG8ucmFuZG9tQnl0ZXMoMSkucmVhZFVJbnQ4KCkgLyAweGZmO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgVUxJREVycm9yKFVMSURFcnJvckNvZGUuUFJOR0RldGVjdEZhaWx1cmUsIFwiRmFpbGVkIHRvIGZpbmQgYSByZWxpYWJsZSBQUk5HXCIpO1xufVxuZnVuY3Rpb24gZGV0ZWN0Um9vdCgpIHtcbiAgICBpZiAoaW5XZWJXb3JrZXIoKSlcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgcmV0dXJuIGdsb2JhbDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHJldHVybiBnbG9iYWxUaGlzO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGVuY29kZVJhbmRvbShsZW4sIHBybmcpIHtcbiAgICBsZXQgc3RyID0gXCJcIjtcbiAgICBmb3IgKDsgbGVuID4gMDsgbGVuLS0pIHtcbiAgICAgICAgc3RyID0gcmFuZG9tQ2hhcihwcm5nKSArIHN0cjtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbn1cbi8qKlxuICogRW5jb2RlIHRoZSB0aW1lIHBvcnRpb24gb2YgYSBVTElEXG4gKiBAcGFyYW0gbm93IFRoZSBjdXJyZW50IHRpbWVzdGFtcFxuICogQHBhcmFtIGxlbiBMZW5ndGggdG8gZ2VuZXJhdGVcbiAqIEByZXR1cm5zIFRoZSBlbmNvZGVkIHRpbWVcbiAqL1xuZnVuY3Rpb24gZW5jb2RlVGltZShub3csIGxlbiA9IFRJTUVfTEVOKSB7XG4gICAgaWYgKGlzTmFOKG5vdykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFVMSURFcnJvcihVTElERXJyb3JDb2RlLkVuY29kZVRpbWVWYWx1ZU1hbGZvcm1lZCwgYFRpbWUgbXVzdCBiZSBhIG51bWJlcjogJHtub3d9YCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vdyA+IFRJTUVfTUFYKSB7XG4gICAgICAgIHRocm93IG5ldyBVTElERXJyb3IoVUxJREVycm9yQ29kZS5FbmNvZGVUaW1lU2l6ZUV4Y2VlZGVkLCBgQ2Fubm90IGVuY29kZSBhIHRpbWUgbGFyZ2VyIHRoYW4gJHtUSU1FX01BWH06ICR7bm93fWApO1xuICAgIH1cbiAgICBlbHNlIGlmIChub3cgPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBVTElERXJyb3IoVUxJREVycm9yQ29kZS5FbmNvZGVUaW1lTmVnYXRpdmUsIGBUaW1lIG11c3QgYmUgcG9zaXRpdmU6ICR7bm93fWApO1xuICAgIH1cbiAgICBlbHNlIGlmIChOdW1iZXIuaXNJbnRlZ2VyKG5vdykgPT09IGZhbHNlKSB7XG4gICAgICAgIHRocm93IG5ldyBVTElERXJyb3IoVUxJREVycm9yQ29kZS5FbmNvZGVUaW1lVmFsdWVNYWxmb3JtZWQsIGBUaW1lIG11c3QgYmUgYW4gaW50ZWdlcjogJHtub3d9YCk7XG4gICAgfVxuICAgIGxldCBtb2QsIHN0ciA9IFwiXCI7XG4gICAgZm9yIChsZXQgY3VycmVudExlbiA9IGxlbjsgY3VycmVudExlbiA+IDA7IGN1cnJlbnRMZW4tLSkge1xuICAgICAgICBtb2QgPSBub3cgJSBFTkNPRElOR19MRU47XG4gICAgICAgIHN0ciA9IEVOQ09ESU5HLmNoYXJBdChtb2QpICsgc3RyO1xuICAgICAgICBub3cgPSAobm93IC0gbW9kKSAvIEVOQ09ESU5HX0xFTjtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbn1cbmZ1bmN0aW9uIGluV2ViV29ya2VyKCkge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICByZXR1cm4gdHlwZW9mIFdvcmtlckdsb2JhbFNjb3BlICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYgaW5zdGFuY2VvZiBXb3JrZXJHbG9iYWxTY29wZTtcbn1cbi8qKlxuICogQ2hlY2sgaWYgYSBVTElEIGlzIHZhbGlkXG4gKiBAcGFyYW0gaWQgVGhlIFVMSUQgdG8gdGVzdFxuICogQHJldHVybnMgVHJ1ZSBpZiB2YWxpZCwgZmFsc2Ugb3RoZXJ3aXNlXG4gKiBAZXhhbXBsZVxuICogICBpc1ZhbGlkKFwiMDFITlpYOEpHRkFDRkEzNlJCWERIRVFONkVcIik7IC8vIHRydWVcbiAqICAgaXNWYWxpZChcIlwiKTsgLy8gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNWYWxpZChpZCkge1xuICAgIHJldHVybiAodHlwZW9mIGlkID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgIGlkLmxlbmd0aCA9PT0gVElNRV9MRU4gKyBSQU5ET01fTEVOICYmXG4gICAgICAgIGlkXG4gICAgICAgICAgICAudG9VcHBlckNhc2UoKVxuICAgICAgICAgICAgLnNwbGl0KFwiXCIpXG4gICAgICAgICAgICAuZXZlcnkoY2hhciA9PiBFTkNPRElORy5pbmRleE9mKGNoYXIpICE9PSAtMSkpO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBVTElEIGZhY3RvcnkgdG8gZ2VuZXJhdGUgbW9ub3RvbmljYWxseS1pbmNyZWFzaW5nXG4gKiAgVUxJRHNcbiAqIEBwYXJhbSBwcm5nIFRoZSBQUk5HIHRvIHVzZVxuICogQHJldHVybnMgQSB1bGlkIGZhY3RvcnlcbiAqIEBleGFtcGxlXG4gKiAgY29uc3QgdWxpZCA9IG1vbm90b25pY0ZhY3RvcnkoKTtcbiAqICB1bGlkKCk7IC8vIFwiMDFITlpYRDA3TTVDRU41WEE2NkVNWlNSWldcIlxuICovXG5mdW5jdGlvbiBtb25vdG9uaWNGYWN0b3J5KHBybmcpIHtcbiAgICBjb25zdCBjdXJyZW50UFJORyA9IHBybmcgfHwgZGV0ZWN0UFJORygpO1xuICAgIGxldCBsYXN0VGltZSA9IDAsIGxhc3RSYW5kb207XG4gICAgcmV0dXJuIGZ1bmN0aW9uIF91bGlkKHNlZWRUaW1lKSB7XG4gICAgICAgIGNvbnN0IHNlZWQgPSAhc2VlZFRpbWUgfHwgaXNOYU4oc2VlZFRpbWUpID8gRGF0ZS5ub3coKSA6IHNlZWRUaW1lO1xuICAgICAgICBpZiAoc2VlZCA8PSBsYXN0VGltZSkge1xuICAgICAgICAgICAgY29uc3QgaW5jcmVtZW50ZWRSYW5kb20gPSAobGFzdFJhbmRvbSA9IGluY3JlbWVudEJhc2UzMihsYXN0UmFuZG9tKSk7XG4gICAgICAgICAgICByZXR1cm4gZW5jb2RlVGltZShsYXN0VGltZSwgVElNRV9MRU4pICsgaW5jcmVtZW50ZWRSYW5kb207XG4gICAgICAgIH1cbiAgICAgICAgbGFzdFRpbWUgPSBzZWVkO1xuICAgICAgICBjb25zdCBuZXdSYW5kb20gPSAobGFzdFJhbmRvbSA9IGVuY29kZVJhbmRvbShSQU5ET01fTEVOLCBjdXJyZW50UFJORykpO1xuICAgICAgICByZXR1cm4gZW5jb2RlVGltZShzZWVkLCBUSU1FX0xFTikgKyBuZXdSYW5kb207XG4gICAgfTtcbn1cbi8qKlxuICogR2VuZXJhdGUgYSBVTElEXG4gKiBAcGFyYW0gc2VlZFRpbWUgT3B0aW9uYWwgdGltZSBzZWVkXG4gKiBAcGFyYW0gcHJuZyBPcHRpb25hbCBQUk5HIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyBBIFVMSUQgc3RyaW5nXG4gKiBAZXhhbXBsZVxuICogIHVsaWQoKTsgLy8gXCIwMUhOWlhEMDdNNUNFTjVYQTY2RU1aU1JaV1wiXG4gKi9cbmZ1bmN0aW9uIHVsaWQoc2VlZFRpbWUsIHBybmcpIHtcbiAgICBjb25zdCBjdXJyZW50UFJORyA9IHBybmcgfHwgZGV0ZWN0UFJORygpO1xuICAgIGNvbnN0IHNlZWQgPSAhc2VlZFRpbWUgfHwgaXNOYU4oc2VlZFRpbWUpID8gRGF0ZS5ub3coKSA6IHNlZWRUaW1lO1xuICAgIHJldHVybiBlbmNvZGVUaW1lKHNlZWQsIFRJTUVfTEVOKSArIGVuY29kZVJhbmRvbShSQU5ET01fTEVOLCBjdXJyZW50UFJORyk7XG59XG5cbi8qKlxuICogQ29udmVydCBhIFVMSUQgdG8gYSBVVUlEXG4gKiBAcGFyYW0gdWxpZCBUaGUgVUxJRCB0byBjb252ZXJ0XG4gKiBAcmV0dXJucyBBIFVVSUQgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIHVsaWRUb1VVSUQodWxpZCkge1xuICAgIGNvbnN0IGlzVmFsaWQgPSBVTElEX1JFR0VYLnRlc3QodWxpZCk7XG4gICAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgICAgIHRocm93IG5ldyBVTElERXJyb3IoVUxJREVycm9yQ29kZS5VTElESW52YWxpZCwgYEludmFsaWQgVUxJRDogJHt1bGlkfWApO1xuICAgIH1cbiAgICBjb25zdCB1aW50OEFycmF5ID0gY3JvY2tmb3JkRGVjb2RlKHVsaWQpO1xuICAgIGxldCB1dWlkID0gQXJyYXkuZnJvbSh1aW50OEFycmF5KVxuICAgICAgICAubWFwKGJ5dGUgPT4gYnl0ZS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgXCIwXCIpKVxuICAgICAgICAuam9pbihcIlwiKTtcbiAgICB1dWlkID1cbiAgICAgICAgdXVpZC5zdWJzdHJpbmcoMCwgOCkgK1xuICAgICAgICAgICAgXCItXCIgK1xuICAgICAgICAgICAgdXVpZC5zdWJzdHJpbmcoOCwgMTIpICtcbiAgICAgICAgICAgIFwiLVwiICtcbiAgICAgICAgICAgIHV1aWQuc3Vic3RyaW5nKDEyLCAxNikgK1xuICAgICAgICAgICAgXCItXCIgK1xuICAgICAgICAgICAgdXVpZC5zdWJzdHJpbmcoMTYsIDIwKSArXG4gICAgICAgICAgICBcIi1cIiArXG4gICAgICAgICAgICB1dWlkLnN1YnN0cmluZygyMCk7XG4gICAgcmV0dXJuIHV1aWQudG9VcHBlckNhc2UoKTtcbn1cbi8qKlxuICogQ29udmVydCBhIFVVSUQgdG8gYSBVTElEXG4gKiBAcGFyYW0gdXVpZCBUaGUgVVVJRCB0byBjb252ZXJ0XG4gKiBAcmV0dXJucyBBIFVMSUQgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIHV1aWRUb1VMSUQodXVpZCkge1xuICAgIGNvbnN0IGlzVmFsaWQgPSBVVUlEX1JFR0VYLnRlc3QodXVpZCk7XG4gICAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgICAgIHRocm93IG5ldyBVTElERXJyb3IoVUxJREVycm9yQ29kZS5VVUlESW52YWxpZCwgYEludmFsaWQgVVVJRDogJHt1dWlkfWApO1xuICAgIH1cbiAgICBjb25zdCBieXRlcyA9IHV1aWQucmVwbGFjZSgvLS9nLCBcIlwiKS5tYXRjaCgvLnsxLDJ9L2cpO1xuICAgIGlmICghYnl0ZXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IFVMSURFcnJvcihVTElERXJyb3JDb2RlLlVuZXhwZWN0ZWQsIGBGYWlsZWQgcGFyc2luZyBVVUlEIGJ5dGVzOiAke3V1aWR9YCk7XG4gICAgfVxuICAgIGNvbnN0IHVpbnQ4QXJyYXkgPSBuZXcgVWludDhBcnJheShieXRlcy5tYXAoYnl0ZSA9PiBwYXJzZUludChieXRlLCAxNikpKTtcbiAgICByZXR1cm4gY3JvY2tmb3JkRW5jb2RlKHVpbnQ4QXJyYXkpO1xufVxuXG5leHBvcnQgeyBNQVhfVUxJRCwgTUlOX1VMSUQsIFRJTUVfTEVOLCBUSU1FX01BWCwgVUxJREVycm9yLCBVTElERXJyb3JDb2RlLCBkZWNvZGVUaW1lLCBlbmNvZGVUaW1lLCBmaXhVTElEQmFzZTMyLCBpbmNyZW1lbnRCYXNlMzIsIGlzVmFsaWQsIG1vbm90b25pY0ZhY3RvcnksIHVsaWQsIHVsaWRUb1VVSUQsIHV1aWRUb1VMSUQgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/ulid@3.0.1/node_modules/ulid/dist/node/index.js\n");

/***/ })

};
;