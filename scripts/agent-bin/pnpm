#!/usr/bin/env bash
set -euo pipefail

# Agent safety wrapper for pnpm.
# Blocks broad test fan-out commands that can overwhelm local machines.

wrapper_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
real_pnpm=""

IFS=":" read -r -a path_entries <<< "${PATH:-}"
for dir in "${path_entries[@]}"; do
  [[ -z "$dir" ]] && continue
  if [[ "$(cd "$dir" 2>/dev/null && pwd)" == "$wrapper_dir" ]]; then
    continue
  fi
  if [[ -x "${dir}/pnpm" ]]; then
    real_pnpm="${dir}/pnpm"
    break
  fi
done

if [[ -z "$real_pnpm" ]]; then
  echo "ERROR: unable to locate real pnpm binary on PATH" >&2
  exit 127
fi

deny() {
  local why="$1"
  shift

  echo "------------------------------------------------------------------" >&2
  echo "BLOCKED: pnpm command guard" >&2
  echo "------------------------------------------------------------------" >&2
  echo "" >&2
  echo "Reason: ${why}" >&2
  echo "" >&2
  echo "Command:" >&2
  printf "  pnpm" >&2
  for arg in "$@"; do
    printf " %q" "$arg" >&2
  done
  echo "" >&2
  echo "" >&2
  echo "Safer alternatives:" >&2
  echo "  - Targeted file test: pnpm --filter <pkg> test -- path/to/file.test.ts" >&2
  echo "  - Affected tests: pnpm test:affected" >&2
  echo "  - Intentional full run: BASESHOP_ALLOW_BROAD_TESTS=1 pnpm test:all" >&2
  echo "" >&2
  exit 1
}

emit_bypass_event() {
  local event_class="$1"
  local mode="${2:-enforce}"
  local repo_root="${BASESHOP_GUARD_REPO_ROOT:-$(git rev-parse --show-toplevel 2>/dev/null || pwd)}"
  local telemetry_script="${repo_root}/scripts/tests/telemetry-log.sh"

  if [[ -x "$telemetry_script" ]]; then
    "$telemetry_script" emit \
      --governed false \
      --policy-mode "$mode" \
      --class "$event_class" \
      --normalized-sig "$event_class" \
      --pressure-level unknown \
      --workers 0 \
      --override-policy-used "${BASESHOP_ALLOW_BYPASS_POLICY:-0}" \
      --override-overload-used "${BASESHOP_ALLOW_OVERLOAD:-0}" >/dev/null 2>&1 || true
  fi
}

block_bypass() {
  local event_class="$1"
  local preview="$2"
  echo "BLOCKED: ungoverned Jest invocation detected (${event_class})." >&2
  echo "Command: ${preview}" >&2
  echo "Recommended: pnpm -w run test:governed -- jest -- <args>" >&2
  if [[ "${BASESHOP_ALLOW_OVERLOAD:-0}" == "1" ]]; then
    echo "Note: BASESHOP_ALLOW_OVERLOAD=1 does not bypass command-policy blocking." >&2
  fi
  echo "Set BASESHOP_ALLOW_BYPASS_POLICY=1 to reroute through the governed runner." >&2
  emit_bypass_event "$event_class" "enforce"
  exit 1
}

reroute_bypass_to_governed() {
  local event_class="$1"
  shift
  echo "BYPASS POLICY OVERRIDE: rerouting '${event_class}' through governed runner." >&2
  emit_bypass_event "$event_class" "enforce"

  local -a reroute_cmd=("$real_pnpm" "-w" "run" "test:governed" "--" "jest")
  if [[ $# -gt 0 ]]; then
    reroute_cmd+=("--" "$@")
  fi
  exec "${reroute_cmd[@]}"
}

if [[ "${BASESHOP_ALLOW_BROAD_TESTS:-}" == "1" ]]; then
  exec "$real_pnpm" "$@"
fi

repo_root="$(git rev-parse --show-toplevel 2>/dev/null || pwd)"
effective_dir="$PWD"
has_filter="0"
has_recursive="0"
has_turbo_scope="0"
is_pnpm_test="0"
is_turbo_test="0"
is_pnpm_exec_jest="0"
has_test_selector="0"
seen_double_dash="0"
declare -a pnpm_exec_jest_args=()

for ((i=1; i<=$#; i++)); do
  arg="${!i}"
  case "$arg" in
    --filter|-F|--filter=*|-F=*)
      has_filter="1"
      has_turbo_scope="1"
      ;;
    -r|--recursive)
      has_recursive="1"
      ;;
    --affected|--only)
      has_turbo_scope="1"
      ;;
    -C|--dir)
      next_i=$((i+1))
      if [[ $next_i -le $# ]]; then
        effective_dir="${!next_i}"
      fi
      ;;
    --dir=*)
      effective_dir="${arg#--dir=}"
      ;;
    -w|--workspace-root)
      effective_dir="$repo_root"
      ;;
  esac
done

for ((i=1; i<=$#; i++)); do
  arg="${!i}"
  if [[ "$arg" == "--" ]]; then
    seen_double_dash="1"
    continue
  fi

  case "$arg" in
    --testPathPattern|--testPathPatterns|--testNamePattern|--runTestsByPath|--findRelatedTests|--changedSince|--changedFilesWithAncestor|-t|--shard)
      has_test_selector="1"
      ;;
    --testPathPattern=*|--testPathPatterns=*|--testNamePattern=*|--changedSince=*|--shard=*)
      has_test_selector="1"
      ;;
    *.test.ts|*.test.tsx|*.test.js|*.test.jsx|*.test.mjs|*.test.cjs|*.spec.ts|*.spec.tsx|*.spec.js|*.spec.jsx|*.spec.mjs|*.spec.cjs)
      has_test_selector="1"
      ;;
    */__tests__/*)
      has_test_selector="1"
      ;;
  esac

  # Jest file and pattern selectors are commonly passed after "--".
  if [[ "$seen_double_dash" == "1" && "$arg" != -* ]]; then
    has_test_selector="1"
  fi

  if [[ "$arg" == "test" || "$arg" == "t" ]]; then
    is_pnpm_test="1"
  fi
  if [[ "$arg" == "run" ]]; then
    next_i=$((i+1))
    if [[ $next_i -le $# ]]; then
      next_arg="${!next_i}"
      if [[ "$next_arg" == "test" || "$next_arg" == "t" ]]; then
        is_pnpm_test="1"
      fi
    fi
  fi
  if [[ "$arg" == "exec" ]]; then
    next_i=$((i+1))
    next2_i=$((i+2))
    next3_i=$((i+3))

    next_arg=""
    next2_arg=""
    next3_arg=""
    if [[ $next_i -le $# ]]; then
      next_arg="${!next_i}"
    fi
    if [[ $next2_i -le $# ]]; then
      next2_arg="${!next2_i}"
    fi
    if [[ $next3_i -le $# ]]; then
      next3_arg="${!next3_i}"
    fi

    if [[ "$next_arg" == "jest" || ( "$next_arg" == "--" && "$next2_arg" == "jest" ) ]]; then
      is_pnpm_exec_jest="1"
    fi

    if [[ "$next_arg" == "turbo" && "$next2_arg" == "run" && "$next3_arg" == "test" ]]; then
      is_turbo_test="1"
    fi
  fi
done

if [[ "$is_pnpm_exec_jest" == "1" ]]; then
  # Capture forwarded Jest args from `pnpm exec jest [--] <args...>`.
  for ((i=1; i<=$#; i++)); do
    arg="${!i}"
    if [[ "$arg" != "exec" ]]; then
      continue
    fi
    cmd_i=$((i + 1))
    if [[ $cmd_i -le $# && "${!cmd_i}" == "--" ]]; then
      cmd_i=$((cmd_i + 1))
    fi
    if [[ $cmd_i -le $# && "${!cmd_i}" == "jest" ]]; then
      args_i=$((cmd_i + 1))
      if [[ $args_i -le $# && "${!args_i}" == "--" ]]; then
        args_i=$((args_i + 1))
      fi
      for ((j=args_i; j<=$#; j++)); do
        pnpm_exec_jest_args+=("${!j}")
      done
      break
    fi
  done

  if [[ "${BASESHOP_GOVERNED_CONTEXT:-0}" != "1" ]]; then
    if [[ "${BASESHOP_ALLOW_BYPASS_POLICY:-0}" == "1" ]]; then
      reroute_bypass_to_governed "pnpm-exec-jest" "${pnpm_exec_jest_args[@]}"
    fi
    block_bypass "pnpm-exec-jest" "pnpm $*"
  fi
fi

is_workspace_root="0"
if [[ -f "${effective_dir%/}/pnpm-workspace.yaml" ]]; then
  is_workspace_root="1"
fi

is_turbo_test_script="0"
pkg_json="${effective_dir%/}/package.json"
if [[ -f "$pkg_json" ]]; then
  if node -e '
const fs = require("fs");
const file = process.argv[1];
try {
  const parsed = JSON.parse(fs.readFileSync(file, "utf8"));
  const testScript = parsed?.scripts?.test;
  if (typeof testScript === "string" && /\bturbo\s+run\s+test\b/.test(testScript)) {
    process.exit(0);
  }
} catch {}
process.exit(1);
' "$pkg_json" >/dev/null 2>&1; then
    is_turbo_test_script="1"
  fi
fi

if [[ "$is_turbo_test" == "1" && "$has_turbo_scope" == "0" ]]; then
  deny "Unscoped 'turbo run test' fans out across many packages and can overwhelm the machine." "$@"
fi

if [[ "$is_pnpm_test" == "1" ]]; then
  if [[ "$has_recursive" == "1" && "$has_filter" == "0" ]]; then
    deny "Recursive test runs without filters can spawn too many concurrent workers." "$@"
  fi
  if [[ "$has_filter" == "0" && "$is_workspace_root" == "1" && "$is_turbo_test" == "0" ]]; then
    deny "Workspace-root 'pnpm test' is disabled to prevent monorepo test fan-out." "$@"
  fi
  if [[ "$has_filter" == "0" && "$is_turbo_test_script" == "1" ]]; then
    deny "Unscoped 'pnpm test' runs a turbo fan-out test script. Use test:affected or filtered tests." "$@"
  fi
  if [[ "$is_turbo_test" == "0" && "$has_filter" == "1" && "$has_test_selector" == "0" ]]; then
    deny "Filtered package test without file/pattern scope is blocked. Run only affected tests." "$@"
  fi
  if [[ "$is_turbo_test" == "0" && "$has_filter" == "0" && "$is_workspace_root" == "0" && "$has_test_selector" == "0" ]]; then
    deny "Unscoped package-local 'pnpm test' is blocked. Run only affected tests." "$@"
  fi
fi

exec "$real_pnpm" "$@"
