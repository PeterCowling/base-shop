// scripts/guides/sync-manifest-entries.ts
import fs from "node:fs/promises";
import path from "node:path";
import { fileURLToPath } from "node:url";

import ts from "typescript";

type EntrySource = {
  key: string;
  text: string;
  usesChecklistNote: boolean;
};

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const ROOT_DIR = path.resolve(__dirname, "..", "..");
const MANIFEST_DIR = path.resolve(ROOT_DIR, "src/routes/guides/manifest");
const LEGACY_FILE = path.join(MANIFEST_DIR, "entries.ts");
const ENTRIES_DIR = path.join(MANIFEST_DIR, "entries");
const DATA_DIR = path.join(ENTRIES_DIR, "data");
const INDEX_FILE = path.join(ENTRIES_DIR, "index.ts");

const GENERATED_WARNING = "// Generated by scripts/guides/sync-manifest-entries.ts";

async function pathExists(target: string): Promise<boolean> {
  try {
    await fs.stat(target);
    return true;
  } catch {
    return false;
  }
}

function sanitizeIdentifier(key: string): string {
  const replaced = key.replace(/[^A-Za-z0-9_$]/g, "_");
  return /^[A-Za-z_$]/.test(replaced) ? replaced : `_${replaced}`;
}

function parseLegacyEntries(sourceText: string): EntrySource[] {
  const file = ts.createSourceFile("entries.ts", sourceText, ts.ScriptTarget.Latest, true, ts.ScriptKind.TS);
  let manifestArray: ts.ArrayLiteralExpression | null = null;

  file.forEachChild((node) => {
    if (!ts.isVariableStatement(node)) return;
    for (const declaration of node.declarationList.declarations) {
      if (!ts.isIdentifier(declaration.name) || declaration.name.text !== "manifestSeed") continue;
      if (declaration.initializer && ts.isArrayLiteralExpression(declaration.initializer)) {
        manifestArray = declaration.initializer;
      }
    }
  });

  if (!manifestArray) {
    throw new Error("Could not find manifestSeed array in legacy manifest file.");
  }

  return manifestArray.elements.map((element) => {
    if (!ts.isCallExpression(element)) {
      throw new Error("Unexpected manifest entry shape (expected GUIDE_MANIFEST_ENTRY_SCHEMA.parse call).");
    }
    const [argument] = element.arguments;
    if (!argument || !ts.isObjectLiteralExpression(argument)) {
      throw new Error("Manifest entry must be initialised with an object literal.");
    }
    const keyProp = argument.properties.find((prop): prop is ts.PropertyAssignment => {
      return (
        ts.isPropertyAssignment(prop) &&
        ((ts.isIdentifier(prop.name) && prop.name.text === "key") ||
          (ts.isStringLiteralLike(prop.name) && prop.name.text === "key"))
      );
    });
    if (!keyProp) {
      throw new Error("Manifest entry is missing a key property.");
    }
    if (!ts.isStringLiteralLike(keyProp.initializer)) {
      throw new Error("Manifest entry key must be a string literal.");
    }
    const key = keyProp.initializer.text;
    const text = sourceText.slice(element.getStart(file), element.getEnd(file)).trim();
    return {
      key,
      text: text.endsWith(";") ? text : `${text};`,
      usesChecklistNote: text.includes("checklistNote("),
    };
  });
}

async function writeEntryFile(entry: EntrySource): Promise<void> {
  const importList = ["GUIDE_MANIFEST_ENTRY_SCHEMA"];
  if (entry.usesChecklistNote) importList.push("checklistNote");
  const importLine = `import { ${importList.join(", ")} } from "../../definitions";`;
  const contents = [importLine, "", `export default ${entry.text}`, ""].join("\n");
  const targetPath = path.join(DATA_DIR, `${entry.key}.ts`);
  await fs.writeFile(targetPath, contents, "utf8");
}

async function generateIndexFile(entryKeys: string[]): Promise<void> {
  const imports = entryKeys
    .map((key) => `import ${sanitizeIdentifier(key)} from "./data/${key}";`)
    .join("\n");
  const manifestArray = entryKeys.map((key) => `  ${sanitizeIdentifier(key)},`).join("\n");
  const contents = [
    GENERATED_WARNING,
    'import type { GuideManifestEntry } from "../definitions";',
    "",
    imports,
    "",
    "const manifestSeedInternal = [",
    manifestArray,
    "] satisfies GuideManifestEntry[];",
    "",
    "export const manifestSeed: GuideManifestEntry[] = manifestSeedInternal;",
    "",
  ].join("\n");
  await fs.writeFile(INDEX_FILE, contents, "utf8");
}

async function ensureEntryModules(): Promise<void> {
  const hasDataDir = await pathExists(DATA_DIR);
  if (!hasDataDir) {
    const hasLegacyFile = await pathExists(LEGACY_FILE);
    if (!hasLegacyFile) {
      throw new Error("No manifest entries directory or legacy entries.ts file found.");
    }
    const legacySource = await fs.readFile(LEGACY_FILE, "utf8");
    const entries = parseLegacyEntries(legacySource);
    await fs.rm(LEGACY_FILE);
    await fs.mkdir(DATA_DIR, { recursive: true });
    for (const entry of entries) {
      await writeEntryFile(entry);
    }
    return;
  }

  const files = await fs.readdir(DATA_DIR);
  if (files.length === 0) {
    throw new Error("Manifest entries data directory is empty. Populate it or restore the legacy manifest file.");
  }
}

async function main(): Promise<void> {
  await ensureEntryModules();
  await fs.mkdir(ENTRIES_DIR, { recursive: true });
  const entryFiles = (await fs.readdir(DATA_DIR))
    .filter((file) => file.endsWith(".ts"))
    .map((file) => path.basename(file, ".ts"))
    .sort((a, b) => a.localeCompare(b));
  if (entryFiles.length === 0) {
    throw new Error("No manifest entry modules found under entries/data.");
  }
  await generateIndexFile(entryFiles);
  console.log(`Generated ${entryFiles.length} manifest entry modules and index.`);
}

main().catch((error) => {
  if (error instanceof Error) {
    console.error(error.stack ?? error.message);
  } else {
    console.error(error);
  }
  process.exitCode = 1;
});