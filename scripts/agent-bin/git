#!/usr/bin/env bash
set -euo pipefail

# This wrapper is intended for agent shells only (see scripts/agents/with-git-guard.sh).
# It blocks a small set of destructive/history-rewriting commands that have caused
# accidental rollbacks and lost work.
#
# Source of truth: docs/git-safety.md § Command Policy Matrix
# When updating patterns, update the matrix first, then this script.

wrapper_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
real_git=""

IFS=":" read -r -a path_entries <<< "${PATH:-}"
for dir in "${path_entries[@]}"; do
  [[ -z "$dir" ]] && continue
  if [[ "$(cd "$dir" 2>/dev/null && pwd)" == "$wrapper_dir" ]]; then
    continue
  fi
  if [[ -x "${dir}/git" ]]; then
    real_git="${dir}/git"
    break
  fi
done

if [[ -z "$real_git" ]]; then
  echo "ERROR: unable to locate real git binary on PATH" >&2
  exit 127
fi

deny() {
  local why="$1"
  shift

  echo "------------------------------------------------------------------" >&2
  echo "GIT COMMAND BLOCKED (agent guard)" >&2
  echo "------------------------------------------------------------------" >&2
  echo "" >&2
  echo "Reason: ${why}" >&2
  echo "" >&2
  echo "Command:" >&2
  printf "  git"
  for arg in "$@"; do
    printf " %q" "$arg"
  done
  echo "" >&2
  echo "" >&2
  echo "Safer alternatives:" >&2
  echo "  - Make a checkpoint commit, then revert if needed" >&2
  echo "  - Use integrator mode (writer lock + guard): scripts/agents/integrator-shell.sh" >&2
  echo "  - Read: docs/git-safety.md" >&2
  echo "" >&2
  exit 1
}

subcommand="${1:-}"

# Block -c core.hooksPath (hook bypass)
for ((i=1; i<=$#; i++)); do
  arg="${!i}"
  if [[ "$arg" == "-c" ]]; then
    next_i=$((i+1))
    if [[ $next_i -le $# ]]; then
      next_arg="${!next_i}"
      if [[ "$next_arg" == core.hooksPath* ]]; then
        deny "Setting core.hooksPath bypasses git hooks." "$@"
      fi
    fi
  fi
done

# Block SKIP_* environment variable bypass attempts
if [[ "${SKIP_WRITER_LOCK:-}" == "1" || "${SKIP_SIMPLE_GIT_HOOKS:-}" == "1" ]]; then
  deny "SKIP_* environment variables bypass safety hooks." "$@"
fi

# Block SKIP_* bypass attempts passed as literal arguments
for arg in "$@"; do
  if [[ "$arg" =~ ^SKIP_(WRITER_LOCK|SIMPLE_GIT_HOOKS) ]]; then
    deny "SKIP_* environment variables bypass safety hooks." "$@"
  fi
done

case "$subcommand" in
  worktree)
    deny "git worktree adds extra checkouts; Base-Shop workflow forbids worktrees." "$@"
    ;;
  reset)
    # Block reset with mode flags
    for arg in "$@"; do
      case "$arg" in
        --hard|--mixed|--merge|--keep)
          deny "git reset with mode flags rewrites state and can lose work." "$@"
          ;;
      esac
    done
    # Block bare reset to earlier commits (e.g. reset HEAD~N)
    # Allow: git reset HEAD file.txt (unstage)
    # Block: git reset HEAD~, git reset HEAD~1, etc.
    for arg in "$@"; do
      if [[ "$arg" =~ ^HEAD~[0-9]*$ ]]; then
        deny "Bare reset to earlier commit (HEAD~N) defaults to --mixed and can lose work." "$@"
      fi
    done
    ;;
  clean)
    # Block any -f variant, but allow dry-run (--dry-run / -n)
    has_dry_run="0"
    for arg in "$@"; do
      if [[ "$arg" == "--dry-run" || "$arg" == "-n" ]]; then
        has_dry_run="1"
      fi
    done

    if [[ "$has_dry_run" == "0" ]]; then
      for arg in "$@"; do
        # Match any flag combination containing 'f' (e.g. -f, -fd, -fdx, -ffdx, -fx)
        if [[ "$arg" =~ ^-[a-zA-Z]*f[a-zA-Z]*$ ]] || [[ "$arg" == "--force" ]]; then
          deny "git clean with -f permanently deletes untracked files. Use --dry-run first or move files to archive/." "$@"
        fi
      done
    fi
    ;;
  push)
    for arg in "$@"; do
      case "$arg" in
        --force|-f|--force-with-lease)
          deny "force-push rewrites remote history and can destroy teammates' work." "$@"
          ;;
        --mirror)
          deny "push --mirror can overwrite all remote refs and destroy work." "$@"
          ;;
        --no-verify|-n)
          deny "push --no-verify bypasses safety hooks." "$@"
          ;;
      esac
    done
    ;;
  rebase)
    deny "rebase rewrites history; use merge commits via PRs instead." "$@"
    ;;
  commit)
    for arg in "$@"; do
      case "$arg" in
        --amend)
          deny "amend rewrites history; prefer a new commit and merge via PR." "$@"
          ;;
        --no-verify)
          deny "commit --no-verify bypasses safety hooks." "$@"
          ;;
      esac
    done
    ;;
  checkout|restore)
    # Block repo-wide/bulk worktree discards and force flags.
    # Allow: single-file worktree restores and index-only restore (--staged).
    # Block: '.', ':/...', directory paths, globs, --force, and multi-path worktree discards.

    has_staged="0"
    has_worktree="0"

    # Check force flags and restore mode flags.
    for arg in "$@"; do
      case "$arg" in
        -f|--force)
          deny "checkout/restore with --force discards local changes destructively." "$@"
          ;;
      esac

      if [[ "$subcommand" == "restore" ]]; then
        case "$arg" in
          --staged)
            has_staged="1"
            ;;
          --worktree)
            has_worktree="1"
            deny "restore --worktree can discard working tree changes." "$@"
            ;;
        esac
      fi
    done

    affects_worktree="1"
    if [[ "$subcommand" == "restore" && "$has_staged" == "1" && "$has_worktree" == "0" ]]; then
      affects_worktree="0"
    fi

    pathspecs=()

    if [[ "$subcommand" == "checkout" ]]; then
      # checkout pathspec mode is only unambiguous after '--'.
      saw_separator="0"
      for arg in "$@"; do
        if [[ "$arg" == "--" ]]; then
          saw_separator="1"
          continue
        fi
        if [[ "$saw_separator" == "1" ]]; then
          pathspecs+=("$arg")
        fi
      done
    else
      # restore accepts pathspecs with or without '--'; parse both forms.
      saw_separator="0"
      skip_next="0"
      for ((i=2; i<=$#; i++)); do
        arg="${!i}"

        if [[ "$skip_next" == "1" ]]; then
          skip_next="0"
          continue
        fi

        if [[ "$arg" == "--" ]]; then
          saw_separator="1"
          continue
        fi

        if [[ "$saw_separator" == "1" ]]; then
          pathspecs+=("$arg")
          continue
        fi

        case "$arg" in
          --source|--pathspec-from-file|-s|--conflict)
            skip_next="1"
            ;;
          --source=*|--pathspec-from-file=*|--conflict=*)
            ;;
          --pathspec-file-nul|--staged|--worktree|--ignore-unmerged|--overlay|--ignore-skip-worktree-bits|--recurse-submodules|--progress|--quiet|--ours|--theirs|--merge|--patch)
            ;;
          -*)
            ;;
          *)
            pathspecs+=("$arg")
            ;;
        esac
      done
    fi

    if [[ "$affects_worktree" == "1" ]]; then
      if [[ "${#pathspecs[@]}" -gt 1 ]]; then
        deny "bulk checkout/restore pathspecs can discard multiple files." "$@"
      fi

      for pathspec in "${pathspecs[@]}"; do
        case "$pathspec" in
          "."|":/"|":/."|":/*")
            deny "repo-wide checkout/restore discards changes." "$@"
            ;;
        esac

        if [[ "$pathspec" =~ /$ ]]; then
          deny "directory checkout/restore (${pathspec}) can discard multiple files." "$@"
        fi

        if [[ "$pathspec" == *"*"* || "$pathspec" == *"?"* || "$pathspec" == *"["* || "$pathspec" == *":(glob)"* ]]; then
          deny "glob checkout/restore pattern (${pathspec}) can discard multiple files." "$@"
        fi
      done
    fi
    ;;
  switch)
    # Block destructive switch operations
    for arg in "$@"; do
      case "$arg" in
        --discard-changes|-f|--force)
          deny "switch with --discard-changes/--force discards local changes." "$@"
          ;;
      esac
    done
    ;;
  stash)
    # Allow: list, show, push
    # Block: pop, apply, drop, clear, and bare stash (no subcommand)
    stash_subcmd="${2:-}"
    case "$stash_subcmd" in
      list|show|push)
        # Allowed
        ;;
      pop|apply|drop|clear)
        deny "stash ${stash_subcmd} can lose work or create merge conflicts." "$@"
        ;;
      "")
        # Bare 'git stash' defaults to 'git stash push' — allowed
        ;;
      *)
        # Unknown subcommand - block to be safe
        deny "stash subcommand '${stash_subcmd}' can hide or lose work in a multi-agent repo." "$@"
        ;;
    esac
    ;;
  config)
    # Block setting core.hooksPath
    for arg in "$@"; do
      if [[ "$arg" == "core.hooksPath" ]] || [[ "$arg" == core.hooksPath=* ]]; then
        deny "Setting core.hooksPath bypasses git hooks." "$@"
      fi
    done
    ;;
esac

exec "$real_git" "$@"
