name: Merge Gate

on:
  pull_request:
  push:
    branches: [main]
  workflow_dispatch:

permissions:
  contents: read
  pull-requests: read
  actions: read
  checks: read

concurrency:
  group: merge-gate-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

jobs:
  gate:
    name: Gate
    runs-on: ubuntu-latest
    timeout-minutes: 60
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Enforce Next.js command policy matrix
        run: node scripts/check-next-webpack-flag.mjs --all

      - name: Detect required workflows
        id: filter
        run: |
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            git diff --name-only "origin/${{ github.base_ref }}...HEAD" > /tmp/changed-files.txt 2>/dev/null || echo "" > /tmp/changed-files.txt
          elif [ "${{ github.event_name }}" = "push" ]; then
            git diff --name-only "${{ github.event.before }}..${{ github.sha }}" > /tmp/changed-files.txt 2>/dev/null || echo "" > /tmp/changed-files.txt
          else
            # workflow_dispatch: treat as all-changed (run everything)
            echo "**/*" > /tmp/changed-files.txt
          fi
          node scripts/ci/path-classifier.cjs --config merge_gate --paths-file /tmp/changed-files.txt --format outputs >> "$GITHUB_OUTPUT"

      - name: Detect i18n resolver contract scope
        id: i18n_contract
        run: |
          if grep -Eq '^(packages/i18n/|packages/next-config/)|(^|/)tsconfig[^/]*\.json$' /tmp/changed-files.txt; then
            echo "run=true" >> "$GITHUB_OUTPUT"
          else
            echo "run=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Set up pnpm for i18n resolver contract
        if: ${{ steps.i18n_contract.outputs.run == 'true' }}
        uses: pnpm/action-setup@v4
        with:
          version: 10.12.1

      - name: Set up Node.js for i18n resolver contract
        if: ${{ steps.i18n_contract.outputs.run == 'true' }}
        uses: actions/setup-node@v4
        with:
          node-version-file: .nvmrc
          cache: pnpm

      - name: Install dependencies for i18n resolver contract
        if: ${{ steps.i18n_contract.outputs.run == 'true' }}
        run: pnpm install --frozen-lockfile

      - name: Enforce i18n resolver contract (scoped)
        if: ${{ steps.i18n_contract.outputs.run == 'true' }}
        run: |
          echo "Running i18n resolver contract checks..."
          node scripts/check-i18n-resolver-contract.mjs --repo-root "$PWD"

      - name: Skip i18n resolver contract (scoped)
        if: ${{ steps.i18n_contract.outputs.run != 'true' }}
        run: echo "Skipping i18n resolver contract checks (no relevant path changes)."

      - name: Lint GitHub Actions workflows
        if: >-
          ${{
            steps.filter.outputs.github_config == 'true' &&
            (
              github.event_name != 'pull_request' ||
              github.base_ref != 'main' ||
              !contains(join(github.event.pull_request.labels.*.name, ','), 'promote-app:')
            )
          }}
        uses: rhysd/actionlint@v1.7.10

      - name: Wait for required workflows
        if: ${{ github.event_name != 'push' }}
        uses: actions/github-script@v7
        env:
          NEED_CORE: ${{ steps.filter.outputs.core }}
          NEED_CMS_DEPLOY: ${{ steps.filter.outputs.cms_deploy }}
          NEED_CMS_E2E: ${{ steps.filter.outputs.cms_e2e }}
          NEED_SKYLAR: ${{ steps.filter.outputs.skylar }}
          NEED_BRIKETTE: ${{ steps.filter.outputs.brikette }}
          NEED_PRIME: ${{ steps.filter.outputs.prime }}
          NEED_PRODUCT_PIPELINE: ${{ steps.filter.outputs.product_pipeline }}
          NEED_STORYBOOK: ${{ steps.filter.outputs.storybook }}
          NEED_CONSENT_ANALYTICS: ${{ steps.filter.outputs.consent_analytics }}
          NEED_LHCI: ${{ steps.filter.outputs.lhci }}
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const sha =
              context.eventName === "pull_request"
                ? context.payload.pull_request.head.sha
                : context.sha;

            const need = {
              core: process.env.NEED_CORE === "true",
              cms_deploy: process.env.NEED_CMS_DEPLOY === "true",
              cms_e2e: process.env.NEED_CMS_E2E === "true",
              skylar: process.env.NEED_SKYLAR === "true",
              brikette: process.env.NEED_BRIKETTE === "true",
              prime: process.env.NEED_PRIME === "true",
              product_pipeline: process.env.NEED_PRODUCT_PIPELINE === "true",
              storybook: process.env.NEED_STORYBOOK === "true",
              consent_analytics: process.env.NEED_CONSENT_ANALYTICS === "true",
              lhci: process.env.NEED_LHCI === "true",
            };

            const requiredWorkflows = [];
            const labels = context.eventName === "pull_request"
              ? (context.payload.pull_request.labels || []).map((l) => l.name)
              : [];
            const scopedPromotionApps = labels
              .filter((label) => label.startsWith("promote-app:"))
              .map((label) => label.slice("promote-app:".length))
              .filter(Boolean);
            const isScopedMainPromotion =
              context.eventName === "pull_request" &&
              context.payload.pull_request.base?.ref === "main" &&
              scopedPromotionApps.length > 0;

            if (isScopedMainPromotion) {
              core.notice(
                `Scoped promotion detected for app(s): ${scopedPromotionApps.join(", ")}. Merge Gate will require only scoped workflows.`
              );
              const scopeWorkflowMap = {
                brikette: [{ id: "brikette.yml", name: "Deploy Brikette" }],
                "business-os": [{ id: "business-os-deploy.yml", name: "Deploy Business OS" }],
                cms: [
                  { id: "cms.yml", name: "Deploy CMS" },
                  { id: "cypress.yml", name: "CMS E2E & Component Tests" },
                ],
                core: [
                  { id: "ci.yml", name: "Core Platform CI" },
                  { id: "storybook.yml", name: "Storybook CI" },
                  { id: "consent-analytics.yml", name: "Consent & Analytics Checks" },
                ],
                prime: [{ id: "prime.yml", name: "Deploy Prime" }],
                "product-pipeline": [{ id: "product-pipeline.yml", name: "Deploy Product Pipeline" }],
                reception: [{ id: "reception.yml", name: "Validate Reception" }],
                skylar: [{ id: "skylar.yml", name: "Deploy Skylar" }],
                shop: [{ id: "ci.yml", name: "Core Platform CI" }],
                xa: [{ id: "xa.yml", name: "Deploy XA (Stealth Staging)" }],
              };
              const dedup = new Map();
              for (const scopedApp of scopedPromotionApps) {
                const workflows = scopeWorkflowMap[scopedApp];
                if (!workflows) {
                  core.warning(`Unknown promotion scope label: promote-app:${scopedApp}`);
                  continue;
                }
                for (const workflow of workflows) {
                  dedup.set(workflow.id, workflow);
                }
                if (scopedApp === "brikette" || scopedApp === "shop" || scopedApp === "skylar") {
                  dedup.set("ci-lighthouse.yml", { id: "ci-lighthouse.yml", name: "Lighthouse CI" });
                }
              }
              requiredWorkflows.push(...dedup.values());
            } else {
              if (need.core) requiredWorkflows.push({ id: "ci.yml", name: "Core Platform CI" });
              if (need.cms_e2e) requiredWorkflows.push({ id: "cypress.yml", name: "CMS E2E & Component Tests" });
              if (need.cms_deploy) requiredWorkflows.push({ id: "cms.yml", name: "Deploy CMS" });
              if (need.skylar) requiredWorkflows.push({ id: "skylar.yml", name: "Deploy Skylar" });
              if (need.brikette) requiredWorkflows.push({ id: "brikette.yml", name: "Deploy Brikette" });
              if (need.prime) requiredWorkflows.push({ id: "prime.yml", name: "Deploy Prime" });
              if (need.product_pipeline) requiredWorkflows.push({ id: "product-pipeline.yml", name: "Deploy Product Pipeline" });
              if (need.storybook) requiredWorkflows.push({ id: "storybook.yml", name: "Storybook CI" });
              if (need.consent_analytics) requiredWorkflows.push({ id: "consent-analytics.yml", name: "Consent & Analytics Checks" });

              // LHCI only runs on PRs when paths changed OR label `run-lhci` is present.
              // Require it only in those cases.
              if (context.eventName === "pull_request") {
                const hasRunLabel = labels.includes("run-lhci");
                if (need.lhci || hasRunLabel) {
                  requiredWorkflows.push({ id: "ci-lighthouse.yml", name: "Lighthouse CI" });
                }
              } else if (context.eventName === "push" && context.ref === "refs/heads/main") {
                // On main, LHCI always runs (but not necessarily required for merges).
                // Don't block the gate on it for push runs.
              }
            }

            if (requiredWorkflows.length === 0) {
              core.notice(`No required workflows for this change set. sha=${sha.slice(0, 7)}`);
              return;
            }

            core.notice(`Merge Gate watching ${requiredWorkflows.length} workflow(s) for sha=${sha.slice(0, 7)}:`);
            for (const w of requiredWorkflows) core.notice(`- ${w.name} (${w.id})`);

            const maxMinutes = 55;
            const pollSeconds = 30;
            const deadline = Date.now() + maxMinutes * 60_000;

            async function resolveWorkflowIds(workflows) {
              const resolved = [];
              for (const wf of workflows) {
                const { data } = await github.rest.actions.getWorkflow({
                  owner,
                  repo,
                  workflow_id: wf.id,
                });
                resolved.push({ ...wf, workflow_numeric_id: data.id });
              }
              return resolved;
            }

            async function listRunsForSha() {
              const params = {
                owner,
                repo,
                head_sha: sha,
                per_page: 100,
              };

              if (context.eventName === "pull_request") {
                params.event = "pull_request";
                params.branch = context.payload.pull_request.head.ref;
              }

              const { data } = await github.rest.actions.listWorkflowRunsForRepo(params);
              return data.workflow_runs ?? [];
            }

            function indexRunsByWorkflowId(runs) {
              const byWorkflowId = new Map();
              for (const run of runs) {
                if (!run?.workflow_id) continue;
                const existing = byWorkflowId.get(run.workflow_id);
                if (!existing) {
                  byWorkflowId.set(run.workflow_id, run);
                  continue;
                }

                if (new Date(run.created_at).getTime() > new Date(existing.created_at).getTime()) {
                  byWorkflowId.set(run.workflow_id, run);
                }
              }

              return byWorkflowId;
            }

            function isTerminalFailure(conclusion) {
              return ["failure", "timed_out", "cancelled", "action_required"].includes(conclusion);
            }

            const requiredWorkflowsWithIds = await resolveWorkflowIds(requiredWorkflows);

            while (true) {
              const runs = await listRunsForSha();
              const runsByWorkflowId = indexRunsByWorkflowId(runs);

              const statuses = [];
              let allDone = true;
              let failed = null;

              for (const wf of requiredWorkflowsWithIds) {
                const run = runsByWorkflowId.get(wf.workflow_numeric_id) ?? null;
                if (!run) {
                  statuses.push(`${wf.name}: pending (no run yet)`);
                  allDone = false;
                  continue;
                }

                if (run.status !== "completed") {
                  statuses.push(`${wf.name}: ${run.status}`);
                  allDone = false;
                  continue;
                }

                const concl = run.conclusion || "unknown";
                statuses.push(`${wf.name}: completed (${concl})`);
                if (isTerminalFailure(concl)) {
                  failed = { wf, run };
                } else if (concl !== "success") {
                  // Treat non-success/non-failure as not mergeable.
                  failed = { wf, run };
                }
              }

              core.notice(statuses.join("\n"));

              if (failed) {
                core.setFailed(
                  `Merge Gate failed: ${failed.wf.name} concluded '${failed.run.conclusion}'. See: ${failed.run.html_url}`
                );
                return;
              }

              if (allDone) {
                core.notice("Merge Gate passed: all required workflows succeeded.");
                return;
              }

              if (Date.now() > deadline) {
                core.setFailed("Merge Gate timed out waiting for required workflows to complete.");
                return;
              }

              await new Promise((r) => setTimeout(r, pollSeconds * 1000));
            }
