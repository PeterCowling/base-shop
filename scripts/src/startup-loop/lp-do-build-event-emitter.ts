/**
 * lp-do-build-event-emitter.ts
 *
 * Canonical per-plan build event emitter for the startup loop.
 * Produces a `build-event.json` artifact after plan completion,
 * carrying operator-attributed outcome fields for the Build Summary generator.
 *
 * Introduced in TASK-05 of startup-loop-why-intended-outcome-automation.
 *
 * Design notes:
 * - `emitBuildEvent()` is a pure function (no FS side effects).
 * - `writeBuildEvent()` writes atomically (temp file + rename).
 * - `readBuildEvent()` returns null on any parse error or missing file (safe fallback).
 * - `why_source` values: "operator" | "auto" | "heuristic" | "compat-v1"
 *   - "operator": values authored by operator at Option B confirmation (dispatch.v2 with source: "operator")
 *   - "auto": values auto-generated by the system (dispatch.v2 with source: "auto")
 *   - "heuristic": fallback — no canonical outcome contract present in build-record
 *   - "compat-v1": dispatch.v1 compat reader path (TASK-08)
 */

import * as fs from "node:fs";
import * as os from "node:os";
import * as path from "node:path";

export const BUILD_EVENT_SCHEMA_VERSION = "build-event.v1" as const;
export const BUILD_EVENT_FILENAME = "build-event.json" as const;

export type BuildEventWhySource = "operator" | "auto" | "heuristic" | "compat-v1";

export interface BuildEventIntendedOutcome {
  type: "measurable" | "operational";
  statement: string;
  source: "operator" | "auto";
}

/**
 * Canonical build event artifact schema (build-event.v1).
 * Written to `docs/plans/<slug>/build-event.json` at build completion.
 * Consumed by `generate-build-summary.ts` when a strategy artifact
 * carries a `Build-Event-Ref: docs/plans/<slug>/build-event.json` frontmatter field.
 */
export interface BuildEvent {
  schema_version: typeof BUILD_EVENT_SCHEMA_VERSION;
  build_id: string;
  feature_slug: string;
  emitted_at: string;
  why: string;
  why_source: BuildEventWhySource;
  intended_outcome: BuildEventIntendedOutcome | null;
}

/**
 * Input to the build event emitter.
 * Caller (lp-do-build skill) is responsible for populating fields
 * from the build-record `## Outcome Contract` section.
 */
export interface BuildEventInput {
  feature_slug: string;
  build_id: string;
  /** Operator-authored or auto-generated why string. Use "—" if absent. */
  why: string;
  /** Source attribution for the why field. */
  why_source: BuildEventWhySource;
  /** Typed intended outcome, or null if no canonical contract present. */
  intended_outcome: BuildEventIntendedOutcome | null;
  /** ISO 8601 emission timestamp. Defaults to current time if omitted. */
  emitted_at?: string;
}

/**
 * Pure function — no FS side effects.
 * Produces a canonical BuildEvent from the given input.
 */
export function emitBuildEvent(input: BuildEventInput): BuildEvent {
  const emitted_at = input.emitted_at ?? new Date().toISOString();

  return {
    schema_version: BUILD_EVENT_SCHEMA_VERSION,
    build_id: input.build_id,
    feature_slug: input.feature_slug,
    emitted_at,
    why: input.why,
    why_source: input.why_source,
    intended_outcome: input.intended_outcome,
  };
}

/**
 * Returns the canonical path for build-event.json within the given plan directory.
 */
export function getBuildEventPath(planDir: string): string {
  return path.join(planDir, BUILD_EVENT_FILENAME);
}

/**
 * Writes a BuildEvent to `<planDir>/build-event.json` atomically (temp + rename).
 * Idempotent: re-running with identical input produces identical file content.
 * Creates the planDir if it does not exist.
 */
export function writeBuildEvent(event: BuildEvent, planDir: string): void {
  fs.mkdirSync(planDir, { recursive: true });

  const targetPath = getBuildEventPath(planDir);
  const json = `${JSON.stringify(event, null, 2)}\n`;

  // Atomic write: write to temp file in same directory, then rename.
  const tmpPath = path.join(
    path.dirname(targetPath),
    `.${BUILD_EVENT_FILENAME}.${process.pid}.${Date.now()}.tmp`,
  );

  try {
    fs.writeFileSync(tmpPath, json, "utf-8");
    fs.renameSync(tmpPath, targetPath);
  } catch (error) {
    // Clean up tmp file on failure
    try {
      fs.unlinkSync(tmpPath);
    } catch {
      // Ignore cleanup errors
    }
    throw error;
  }
}

/**
 * Reads and parses build-event.json from the given plan directory.
 * Returns null if the file does not exist or cannot be parsed.
 * Never throws — safe to call speculatively.
 */
export function readBuildEvent(planDir: string): BuildEvent | null {
  const targetPath = getBuildEventPath(planDir);

  try {
    const raw = fs.readFileSync(targetPath, "utf-8");
    const parsed = JSON.parse(raw) as BuildEvent;

    // Basic schema guard
    if (parsed.schema_version !== BUILD_EVENT_SCHEMA_VERSION) {
      return null;
    }

    return parsed;
  } catch {
    return null;
  }
}

/**
 * Resolves the plan directory from a repo root and feature slug.
 */
export function getPlanDir(repoRoot: string, featureSlug: string): string {
  return path.join(repoRoot, "docs", "plans", featureSlug);
}
