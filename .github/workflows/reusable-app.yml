name: Reusable App Pipeline

on:
  workflow_call:
    inputs:
      # Filter for pnpm commands, e.g. "@apps/cms" or "@apps/skylar"
      app-filter:
        required: true
        type: string
      # Command to build the app, e.g. "pnpm --filter @apps/skylar build"
      build-cmd:
        required: true
        type: string
      # Directory to archive/upload after build, e.g. "apps/skylar/out".
      # Leave empty if the deploy command handles its own build.
      artifact-path:
        required: false
        type: string
      # Command to deploy, e.g. "pnpm exec wrangler pages deploy ..."
      deploy-cmd:
        required: false
        type: string
      # Cloudflare project name (for environment context or logs)
      project-name:
        required: false
        type: string
      # GitHub "environment" name (used for URL display and any environment rules)
      environment-name:
        required: false
        type: string
        default: "production"
      # GitHub "environment" URL displayed in the Actions UI
      # (Useful when deploying preview branches or custom domains.)
      environment-url:
        required: false
        type: string
        default: ""
      # Extra args for scripts/post-deploy-health-check.sh (e.g. "--staging")
      healthcheck-args:
        required: false
        type: string
        default: ""
      # Optional override for the health check URL (e.g. custom domain)
      healthcheck-base-url:
        required: false
        type: string
        default: ""
      # Number of test shards for Brikette CI path. Values other than 3
      # currently fall back to the default single test job.
      test-shard-count:
        required: false
        type: number
        default: 1

    secrets:
      CLOUDFLARE_API_TOKEN:
        required: true
      CLOUDFLARE_ACCOUNT_ID:
        required: true
      TURBO_TOKEN:
        required: false
      SOPS_AGE_KEY:
        required: false
      NEXTAUTH_SECRET:
        required: false
      SESSION_SECRET:
        required: false
      CART_COOKIE_SECRET:
        required: false

jobs:
  validate:
    name: Validate
    runs-on: ubuntu-latest
    timeout-minutes: 30
    outputs:
      run_validation: ${{ steps.classify.outputs.run_validation }}
      run_sharded_tests: ${{ steps.test-strategy.outputs.run_sharded_tests }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - uses: ./.github/actions/setup-repo
        with:
          turbo-token: ${{ secrets.TURBO_TOKEN }}
          turbo-team: ${{ vars.TURBO_TEAM }}

      - name: Classify deploy-only change set
        id: classify
        shell: bash
        env:
          APP_FILTER: ${{ inputs.app-filter }}
          PR_BASE_SHA: ${{ github.event.pull_request.base.sha || '' }}
          EVENT_BEFORE: ${{ github.event.before || '' }}
        run: |
          set -euo pipefail

          run_validation="true"
          is_deploy_only="false"
          uncertain="true"
          reason="non_brikette_caller"
          changed_file_count="0"

          if [[ "$APP_FILTER" == "@apps/brikette" ]]; then
            base_sha=""
            if [[ -n "$PR_BASE_SHA" ]]; then
              base_sha="$PR_BASE_SHA"
            elif [[ -n "$EVENT_BEFORE" && "$EVENT_BEFORE" != "0000000000000000000000000000000000000000" ]]; then
              base_sha="$EVENT_BEFORE"
            elif git rev-parse HEAD^ >/dev/null 2>&1; then
              base_sha="$(git rev-parse HEAD^)"
            fi

            changed_paths_file="$RUNNER_TEMP/changed-paths.txt"
            if [[ -n "$base_sha" ]]; then
              git diff --name-only "$base_sha" "${GITHUB_SHA}" > "$changed_paths_file"
            else
              : > "$changed_paths_file"
            fi
            changed_file_count="$(wc -l < "$changed_paths_file" | tr -d ' ')"

            classification_stderr_file="$RUNNER_TEMP/classify-deploy-change.stderr"
            if classification_output="$(
              node --import tsx scripts/src/ci/classify-deploy-change.ts \
                --paths-file "$changed_paths_file" \
                --format outputs \
                2> "$classification_stderr_file"
            )"; then
              while IFS='=' read -r key value; do
                case "$key" in
                  run_validation) run_validation="$value" ;;
                  is_deploy_only) is_deploy_only="$value" ;;
                  uncertain) uncertain="$value" ;;
                  reason) reason="$value" ;;
                esac
              done <<< "$classification_output"

              if [[ "$run_validation" != "true" && "$run_validation" != "false" ]] \
                || [[ "$is_deploy_only" != "true" && "$is_deploy_only" != "false" ]] \
                || [[ "$uncertain" != "true" && "$uncertain" != "false" ]] \
                || [[ -z "$reason" ]]; then
                echo "::warning title=Validation gating::Classifier output parse failed; running full validation."
                run_validation="true"
                is_deploy_only="false"
                uncertain="true"
                reason="classifier_parse_failed"
              fi
            else
              echo "::warning title=Validation gating::Classifier command failed; running full validation."
              if [[ -s "$classification_stderr_file" ]]; then
                sed 's/^/classifier stderr: /' "$classification_stderr_file"
              fi
              is_deploy_only="false"
              uncertain="true"
              reason="classifier_command_failed"
              run_validation="true"
            fi
          fi

          {
            echo "run_validation=$run_validation"
            echo "is_deploy_only=$is_deploy_only"
            echo "uncertain=$uncertain"
            echo "reason=$reason"
            echo "changed_file_count=$changed_file_count"
          } >> "$GITHUB_OUTPUT"

      - name: Validation gating decision
        shell: bash
        run: |
          set -euo pipefail
          if [[ "${{ steps.classify.outputs.run_validation }}" == "false" ]]; then
            echo "::notice title=Validation gating::Skipping Lint/Typecheck/Test (deploy-only, confident). reason=${{ steps.classify.outputs.reason }} changed_files=${{ steps.classify.outputs.changed_file_count }}"
          else
            echo "::notice title=Validation gating::Running full validation. reason=${{ steps.classify.outputs.reason }} uncertain=${{ steps.classify.outputs.uncertain }} changed_files=${{ steps.classify.outputs.changed_file_count }}"
          fi

      - name: Determine test strategy
        id: test-strategy
        shell: bash
        env:
          APP_FILTER: ${{ inputs.app-filter }}
          TEST_SHARD_COUNT: ${{ inputs.test-shard-count }}
        run: |
          set -euo pipefail
          if [[ "$APP_FILTER" == "@apps/brikette" && "$TEST_SHARD_COUNT" -eq 3 ]]; then
            echo "run_sharded_tests=true" >> "$GITHUB_OUTPUT"
            echo "::notice title=Test strategy::Using Brikette sharded test mode (3 shards)."
          else
            echo "run_sharded_tests=false" >> "$GITHUB_OUTPUT"
            echo "::notice title=Test strategy::Using single test job."
          fi

      - name: Lint
        if: ${{ steps.classify.outputs.run_validation == 'true' }}
        run: pnpm --filter ${{ inputs.app-filter }}... lint
        shell: bash

      - name: Typecheck
        if: ${{ steps.classify.outputs.run_validation == 'true' }}
        run: pnpm exec turbo run typecheck --filter=${{ inputs.app-filter }}...
        shell: bash

      - name: Firebase cost-safety gate (Prime)
        if: ${{ steps.classify.outputs.run_validation == 'true' && inputs.app-filter == '@apps/prime' }}
        run: pnpm --filter @apps/prime test:firebase-cost-gate
        shell: bash

      - name: Validate guide manifest (warn-only)
        if: ${{ inputs.app-filter == '@apps/brikette' }}
        run: |
          echo "::group::Guide Manifest Validation"
          pnpm --filter @apps/brikette validate-manifest --warn-only || true
          echo "::endgroup::"
        shell: bash
        continue-on-error: true

      - name: Guide coverage report
        if: ${{ inputs.app-filter == '@apps/brikette' }}
        run: |
          echo "::group::Guide Coverage Report"
          pnpm --filter @apps/brikette report-coverage || true
          echo "::endgroup::"
        shell: bash
        continue-on-error: true

  test:
    name: Test
    if: ${{ needs.validate.outputs.run_validation == 'true' && needs.validate.outputs.run_sharded_tests != 'true' }}
    needs: validate
    runs-on: ubuntu-latest
    timeout-minutes: 20
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - uses: ./.github/actions/setup-repo
        with:
          turbo-token: ${{ secrets.TURBO_TOKEN }}
          turbo-team: ${{ vars.TURBO_TEAM }}
      - name: Run tests
        run: pnpm --filter ${{ inputs.app-filter }} test
        shell: bash

  test-sharded:
    name: Test (shard ${{ matrix.shard }}/3)
    if: ${{ needs.validate.outputs.run_validation == 'true' && needs.validate.outputs.run_sharded_tests == 'true' }}
    needs: validate
    runs-on: ubuntu-latest
    timeout-minutes: 20
    strategy:
      fail-fast: false
      matrix:
        shard: [1, 2, 3]
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - uses: ./.github/actions/setup-repo
        with:
          turbo-token: ${{ secrets.TURBO_TOKEN }}
          turbo-team: ${{ vars.TURBO_TEAM }}
      - name: Restore Jest/ts-jest caches (Brikette shards)
        uses: actions/cache@v4
        with:
          path: |
            .ts-jest
            node_modules/.cache/jest
            apps/brikette/node_modules/.cache/jest
          key: brikette-jest-cache-${{ runner.os }}-${{ hashFiles('pnpm-lock.yaml') }}-${{ matrix.shard }}
          restore-keys: |
            brikette-jest-cache-${{ runner.os }}-${{ hashFiles('pnpm-lock.yaml') }}-
      - name: Run Brikette test shard (${{ matrix.shard }}/3)
        run: |
          pnpm --filter @apps/brikette exec jest --ci --runInBand --passWithNoTests \
            --shard=${{ matrix.shard }}/3
        shell: bash

  build:
    name: Build
    needs: [validate, test, test-sharded]
    if: ${{ needs.validate.result == 'success' && (needs.test.result == 'success' || needs.test.result == 'skipped') && (needs['test-sharded'].result == 'success' || needs['test-sharded'].result == 'skipped') }}
    runs-on: ubuntu-latest
    timeout-minutes: 30
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - uses: ./.github/actions/setup-repo
        with:
          turbo-token: ${{ secrets.TURBO_TOKEN }}
          turbo-team: ${{ vars.TURBO_TEAM }}
      - name: Build
        run: ${{ inputs.build-cmd }}
        shell: bash

      - name: Upload Artifact
        if: ${{ inputs.artifact-path != '' }}
        uses: actions/upload-artifact@v4
        with:
          name: build-artifact-${{ inputs.project-name }}
          path: ${{ inputs.artifact-path }}
          include-hidden-files: true
          retention-days: 1

  deploy:
    name: Deploy
    # Only deploy if a deploy command is provided AND we are on main or staging
    if: ${{ inputs.deploy-cmd != '' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/staging') }}
    needs: build
    runs-on: ubuntu-latest
    timeout-minutes: 15
    environment:
      name: ${{ inputs.environment-name }}
      url: ${{ inputs.environment-url != '' && inputs.environment-url || format('https://{0}.pages.dev', inputs.project-name) }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - uses: ./.github/actions/setup-repo
        with:
          turbo-token: ${{ secrets.TURBO_TOKEN }}
          turbo-team: ${{ vars.TURBO_TEAM }}

      - name: Download Artifact
        if: ${{ inputs.artifact-path != '' }}
        uses: actions/download-artifact@v4
        with:
          name: build-artifact-${{ inputs.project-name }}
          path: ${{ inputs.artifact-path }}

      # ADMIN-04: Decrypt SOPS secrets before deploy
      - name: Decrypt secrets
        uses: ./.github/actions/decrypt-secrets
        with:
          sops-age-key: ${{ secrets.SOPS_AGE_KEY }}
          environment: "${{ github.ref_name == 'staging' && 'preview' || 'production' }}"

      # ADMIN-05: Validate environment before deploy
      - name: Validate deploy environment
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          NEXTAUTH_SECRET: ${{ secrets.NEXTAUTH_SECRET }}
          SESSION_SECRET: ${{ secrets.SESSION_SECRET }}
          CART_COOKIE_SECRET: ${{ secrets.CART_COOKIE_SECRET }}
        run: |
          chmod +x scripts/validate-deploy-env.sh
          ./scripts/validate-deploy-env.sh
        shell: bash

      - name: Deploy
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          NEXTAUTH_SECRET: ${{ secrets.NEXTAUTH_SECRET }}
          SESSION_SECRET: ${{ secrets.SESSION_SECRET }}
          CART_COOKIE_SECRET: ${{ secrets.CART_COOKIE_SECRET }}
        run: ${{ inputs.deploy-cmd }}
        shell: bash

      - name: Post-Deploy Health Check
        if: success() && inputs.project-name != ''
        run: |
          chmod +x scripts/post-deploy-health-check.sh
          ./scripts/post-deploy-health-check.sh ${{ inputs.project-name }} ${{ inputs.healthcheck-args }}
        shell: bash
        # NOTE: keep these env vars here so all app deploys get consistent behavior.
        # Apps can still override via the reusable-workflow inputs (BASE_URL) or by
        # passing EXTRA_ROUTES/MAX_RETRIES/RETRY_DELAY in their caller workflow.
        # (If you need per-app values, extend this reusable workflow rather than
        # copy-pasting it.)
        env:
          BASE_URL: ${{ inputs.healthcheck-base-url }}
          EXTRA_ROUTES: "/api/health"
          MAX_RETRIES: "10"
          RETRY_DELAY: "6"

      - name: Post-Deploy Cache Headers Check (Brikette)
        if: success() && inputs.app-filter == '@apps/brikette' && inputs.project-name != '' && inputs.environment-name == 'production'
        run: |
          chmod +x scripts/post-deploy-brikette-cache-check.sh
          ./scripts/post-deploy-brikette-cache-check.sh ${{ inputs.project-name }} ${{ inputs.healthcheck-args }}
        shell: bash
        env:
          BASE_URL: ${{ inputs.healthcheck-base-url }}
